---
slug: unit-testing
title: Unit testing
tags: [test, unit test, programming]
description: Today's article is done in joint effort with my former colleague and mentor <a href="https://www.linkedin.com/in/guillaumefaas/" target="_blank" rel="noreferrer noopener nofollow">Guillaume Faas</a> (ðŸ”¹) in the form of an interview of a developer. Please join me to thank him for his incredible involvement in the writing of this post! We both hope you are gonna love it as much as we loved writing it.
image: img/unit-testing.jpg
---

import Figure from '../src/components/figure';
import SEO from '../src/components/seo';
import Reminder from '../src/components/reminder';
import Newsletter from '../src/components/newsletter';
import { MAILCHIMP_URL } from '../website_config.json';
import { AnchoredH2, AnchoredP } from '../src/components/AnchoredHeading';
import randomChoose from '../src/utils/randomChoose';

<a href='/blog/unit-testing'>
	<Figure
		data={{
			src: '/img/unit-testing.jpg',
			alt: 'Unit tests',
			type: 'image',
		}}
	/>
</a>

Today's article is done in joint effort with my former colleague and mentor <a href="https://www.linkedin.com/in/guillaumefaas/" target="_blank" rel="noreferrer noopener nofollow">Guillaume Faas</a>
(ðŸ”¹) in the form of an interview of a developer.

Please join me to thank him for his incredible involvement in the writing of this post! We both hope you are gonna love it as much as we loved writing it.

<!--truncate-->

<SEO uri='blog/unit-testing' image='img/unit-testing.jpg' type='article' />

---

<Reminder />

---

_tldr; Do katas with the "Test Driven Development" methodology!_

<AnchoredH2 id='presentation'>Presentation</AnchoredH2>

<AnchoredP>ðŸ”¸ Hey Guillaume ! Can you introduce yourself please?</AnchoredP>

ðŸ”¹ Hello TinaÃ«l! Thank you for inviting me to speak on your blog. My name is Guillaume Faas and I am a .NET expert / Software Craftsman, actually working at [Squaremiled S.A.](https://squaremiled.com/).
I've been building softwares since 10 years or so, in various environments and business sectors.

<AnchoredH2 id='topic'>The topic!</AnchoredH2>

<AnchoredP>ðŸ”¸ What are we going to talk about today?</AnchoredP>

ðŸ”¹ What do you think? It seems someone did not read the post's title. We are going to talk about **unit testing**!

<AnchoredP id='first-encounter'>
	ðŸ”¸ When did you first encounter unit testing?
</AnchoredP>

ðŸ”¹ It was a long time ago in a galaxy far, far away... I barely had a few years of experience.
I've been working in the same company for most of my career, and compared to my day-to-day, I thought I had seen it all.
I started looking online in guideliens, best practices, patterns and so on... I came across a lot of exciting and above all new topics.
I seemed like I stepped in a new world that had nothing to do with my daily life in which I was stuck. The _testing_ was obviously one of those topics.
However, I quickly realised that I had to progress in other subjets before I could introduce tests in my projects. It took me quite a long time before I was really fit to work in a test-driven approach.

<AnchoredP id='what-is-it'>
	ðŸ”¸ Ok! However, just not to lose our readers... can you explain what a unit
	test is please?
</AnchoredP>

ðŸ”¹ Yes, of course! A unit test is a test that checks a _unit of code_. This concept of unit of code varies according to the testing schools.
The London (or Mockist) School will see it as the smallest chunk of code so we are talking about a class or a method.
On the other hand, the Detroit (or Classicist) School will see it as a group of classes or methods.
For the most curious of you, here's an [article](https://medium.com/@adrianbooth/test-driven-development-wars-detroit-vs-london-classicist-vs-mockist-9956c78ae95f) which gives details on the differences between both schools. I want to clarify that no school is better than the other, each one having its pros and cons.
It's only a matter of preference and compromise.
The main difference is mainly the size of your _System Under Test_ (SUT) and the relationship between the different collaborators.

But in the end, a unit test is simply **a piece of code validating that another piece of code has the expected result and/or side effect against a given scenario**.

<AnchoredP id='hierarchy-position'>
	ðŸ”¸ Alright. Where is it in this "test hierarchy"?
</AnchoredP>

ðŸ”¹ It looks like the Agile Testing Pyramid but from left to right instead of bottom to top.
The more on the left, the smaller your scope is and the most numerous and faster your tests will be.
If you read it the other way and apply a reverse logic, it works too.

We are on the "unit" part for this topic since there is technically nothing smaller than a unit. A unit test should be executed on a standalone basis in a sandboxed environment.
That is, a unit test has no impact on the outside of its scope, and if you run several of them in parallel, they must not have any side effect between them.

This finally means that in a unit test: we do not contact a database, we avoid making HTTP requests, access file system, etc. In the same way, we are not going to contact the other dependencies of the solution.
We strictly stay "internal" to the unit.

<Figure
	data={{
		src: '/img/software-testing-types.png',
		alt: 'Types of Software Testing',
		type: 'image',
	}}
/>

Here are a few points on the _functional testing_ part:

-   the unit testing is to check that a component works well. It is the fastest, we will talk about "fast feedback loop" ;
-   the integration testing is to check that several components work well together ;
-   the user acceptance testing consists of verifying the whole application while avoiding contact with external dependencies (eg: requests to external providers).
    This is the most representative test, probably the one that has the most value on the product scale as it validates business requirements.

Note that you don't have to implement them all. We could have a test suite only composed of tests from a single category.
But it should be borne in mind that our test suite will not be the most effective.

<AnchoredP>
	ðŸ”¸ Nice! But why is testing not used everywhere in the profesionnal world?
</AnchoredP>

ðŸ”¹ In reality, a large part of developers write little to no tests. In addition, integration tests are less common than unit tests because they are more complex to write.
In the end, this task is often seen as a chore or an extra step that we will only do if we have time.

<Figure
	data={{
		src: randomChoose(
			'https://miro.medium.com/max/600/1*xHibbXdcePT0GtpeZRgxSA.gif',
			'https://media4.giphy.com/media/hqq505vU9iHCOGySD5/giphy.gif',
			'https://media1.giphy.com/media/VXmWbcDSj2yqnsXUrF/giphy.gif'
		),
		alt: 'GIF on integration tests',
		type: 'image',
	}}
/>

Uncle Bob also spoke about it at a conference in London in 2018:

<Figure
	data={{
		type: 'html',
		width: '560',
		height: '315',
		src: 'https://www.youtube.com/embed/17vTLSkXTOo?start=552&end=720',
		title: 'YouTube video player of SC London Conference 2018',
		allow: 'accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture',
		allowFullScreen: true,
	}}
/>

<AnchoredP id='objective'>
	ðŸ”¸ What is the objective of unit testing and when should it be applied?
</AnchoredP>

ðŸ”¹ The goal is quite simple: it's to show that a method works as expected. That is, you are going to have an expected behavior. For example, a method `getSomething` should return you something.
You are thus going to test different scenarios and check that the method always behaves the right way.

As for the "when", it's even simpler: you need to apply unit testing whenever you have some logic somewhere.

<AnchoredP id='pros-and-cons'>
	ðŸ”¸ Alrighty! What are the pros and cons of such thing?
</AnchoredP>

ðŸ”¹ As previously said, you write code to test code. Seen like this, it surely looks like additional workload but there are realy interests behind!

1. The unit test acts as a **safety net against regressions**.

The refactoring stage systematically occurs in a projet. The problem is, when you start changing something, there is always **a risk of regression**.
We talk about regression when something that used to work does not anymore due to some changes.
It's precisely here that a unit test intervene: it guarantees that your components always work as expected. If anything does not work anymore after a refactoring, the test suite is going to display erroneous code with a beautiful red dot.
And that, in the point of view of a developer, it's huge! It means you can be much more relaxed and spend less time checking that your changes did not have undesirable effect on the rest of the features.

2. Writing tests improves the **code quality** of your app.

It is related to the above that we have just discussed. It is likely that the readers have already encountered a similar situation:
when talking about refactoring to a Product Owner or a Product Manager, the first fear is always that is not working anymore.
If you are covered by a test suite, you are not afraid of refactoring. It's even the opposite, **you are encouraged to refactor regularly** while being protected.

3. A test suite becomes what we call **a living documentation**.

When we talk about documentation, we might all have commentaries in mind. The problem is that they are never up to date with the rest of the code. The code evolves, the documentation does not.
However, your unit test will always be up to date. If it wasn't, your test suite wouldn't give you the green light to go further.

It's even more interesting when^in the context of the arrival of a new developer on the project. Rather than reading all the code of a method to know what it does, they can just look at the different tests for that specific method.
Each behavior will be represented by a test with an explicit naming on the scenario and expected result (eg: `GetItem_ShouldReturnNotFoundResult_GivenItemIsMissing`). **It makes the onboarding process easier!**

4. It **reduces the bug detection time**.

We mentioned the concept of "short feedback loop" earlier. Unit tests are really fast to execute, they give an almost instantaneous feedback on the health of the solution.
This means that we need to regularly execute them. Let's say we have a button (or a shortcut) that gives us a Green/Red status in a few seconds. Activating this button must become systematic.

It already has an interest for us developers but that's not all. We'll talk about it later!

5. It is not a direct advantage but more like a side effect: **testing makes you better**.

To ensure you write tests that provide real value, there are certain principles that you need to follow. You must always have a certain layer of abstraction to _mock_ your dependencies, you must be able to inject them, you must limit the responsibilities of your components, etc.
In fact, you will force yourself to apply several principles regularly (eg: SOLID). Suddenly, it forces you to break your components, to decouple them, to think about their interactions and responsibilities. In short, to think and ask yourself a lot of questions.
Casually, we are talking about _code design_! And so, action-reaction: you get better over time. Sounds very "Happy End" but you know where I'm going with this.

ðŸ”¸ And as it is not that much introduced in companies, it's kinda "new" and motivates to learn more!

ðŸ”¹ I agree with you on the novelty aspect but it only remains present when the subject is discovered. And there's an interpretive part to it all: some (like you) see it as something interesting. Others see it as a chore or extra pressure.
You will always find people resistant to testing for a variety of reasons. Perhaps we will have the opportunity to address the reasons that are generally mentioned...

To get back to the question, here are the cons that come to my mind:

1. Already mentioned, but there are pre-requisites: you have to understand the foundation of the Object-Oriented, dependency injection, [SOLID](https://www.digitalocean.com/community/conceptual_articles/s-o-l-i-d-the-first-five-principles-of-object-oriented-design) principles, etc.
2. The fact that there are few projects with real test suites makes learning less accessible. The same goes for a coach passionate about this subject.
3. There's a fairly steep learning/progression curve. Everyone goes through a phase of frustration at the beginning because we are not comfortable and we have the impression of being slower.
   We must resist and persevere because the tests will actually make us go faster in the long go. We will talk about it with the TDD approach.
4. It requires preparation: you have to think about the project's architecture, the relationships between the different components, etc. Seen like this, it isn't really a disadvantage but we can't (won't anymore?) go headlong in a development without a minimum of thought.
5. There is a lack of comprehension on the side of other teams involved in the proect development, especially non-IT's. We always fall back on discussions about the "Return On Investment" (ROI) or the impact on velocity.

We often hear that "it takes time" or "it will be planned later" or "developers don't have time" but those arguments are not really valid.
Indeed, the first one clearly indicates a lack of long term vision and understanding of testing. Because "later" never happens but above all, writing the tests at the end of a product's development doesn't make any sense. We lose all benefits of testing. I already said it but we will talk about it with the TDD approach.
Then, the second indicates an organizational problem. The tests should be included in the time estimates of developping a feature and not as additional work to be done.

<AnchoredP id='test-coverage'>ðŸ”¸ What about the test coverage?</AnchoredP>

ðŸ”¹ Testing is great, we feel the benefits. However, we is also necessary to make a status on the state of the test suite. This is when we start talking about "code coverage". It is an informative metric about your app's test coverage process.
I really insist on the "informative" side. It would be a mistake to measure the quality of the test suite based on its coverage. It is a metric of quantity, not quality.
I have already read articles about companies that have incorporated the value of code coverage into developer goals and this has prompted developers to use mock tests to boost the coverage.

The only way to check the quality of a test suite of a project is to ask yourself a few questions:

-   Does the general feature development time stay approximately the same over time?
-   Does the quantity of bugs found in production decrease over time?
-   Do you easily manage to welcome new resource within the development team?
-   Do the developers trust their test suite? Is it representative of the state of health of the solution? Does a green circle really guarantee that a component is working?

If you are able to answer "yes" to all these questions, congrats! You can be proud of the test suite that you have put in place.
The problem? It is really difficult to have an answer to all these questions when you have to report _day one_... You also notice that the first three refer to **time**.

<AnchoredP id='cost'>
	ðŸ”¸ Well... Cost wise, where are we? Because ultimately, writing a test means
	writing code. It costs!
</AnchoredP>

ðŸ”¹ I see where you are going with this. No, it does not cost more unless you charge to characters!
Even if you write more code, you really win and not only on the time aspect. Did I tell you we had to talk about the TDD approach? Because it even saves you time in short term. Anyway!

Developing a feature may take you a little longer, knowing that it will mostly depend on your ease to write tests.
On the other hand, it will especially "save your life" a lot of times because you will avoid a lot of bugs which, in normal times, would have arrived much later in your process, during user testing on a QA environment or in production.

But you wanted to talk about money! **The later a bug is discovered, the more it costs**:

<Figure
	data={{
		src: 'https://assets.deepsource.io/995f56d/images/blog/cost-of-fixing-bugs/chart.jpg',
		alt: 'Cost of bug fix',
		type: 'image',
		url: 'https://deepsource.io/blog/exponential-cost-of-fixing-bugs/',
	}}>
	Cost of bug fix based on the moment it was detected, sourced from{' '}
	<a href='https://deepsource.io/blog/exponential-cost-of-fixing-bugs/'>
		DeepSource
	</a>
	!
</Figure>

And is totally normal.

We can talk again about the "fast feedback loop": if a bug is found by a unit test, it's in local, on your machine, just after a change (don't forget to rebuild and rerun your test suite!). The bug is quickly identified and fixed.

In contrast, a bug that goes to production... is discovered by a user who must report the problem to your product team who must analyze the feedback and open a ticket in your backlog.
This ticket will be prioritized by your Product Owner to be included in the next iteration and then it will be assigned to a developer. Assuming that it is not you, there will be an investigation phase (reproduction of the bug), a bug correction phase and after that it goes through all environments and be validated by Quality Assurance Users.

I deliberately took an extreme case scenario to show the worst possible but it's also the best way to be explicit about the problem.
The important thing to remember is that **a test can save a lot of people a lot of time, no matter how simple it is**.

_Ed: to learn more about the reasons that softwares have bugs, do not hesitate to consult [this page](https://www.softwaretestinghelp.com/why-does-software-have-bugs) and [others on the web](https://www.google.com/search?q=why+do+softwares+have+bugs)!_

<AnchoredH2 id='details'>In depth</AnchoredH2>

<AnchoredP id='black-and-white-boxes'>
	ðŸ”¸ Ok! What about we talk about black box and white box testing now?
</AnchoredP>

ðŸ”¹ I like diagrams, do you like diagrams? Diagrams are great!

<Figure
	data={{
		src: '/img/black-white-box-testing.png',
		alt: 'Black and white box testing',
		type: 'image',
		style: { border: '.5em solid black' },
	}}>
	The differences between black and white box testing
</Figure>

**Black box testing** consists in giving an input to the SUT and check the output. It's that simple: we don't take into account things happening inside the method.
There's an accurate case scenario where this type of testing is mandatory: pure methods. Those having no dependencies or shared variables have no side effect.
It's therefore obvious to use black box testing. It makes the test extremely robust because nothing impacts its result.

Let's take a `Sum` method from a `Calculator` class as an example. We are exactly on the scenario mentioned above:

```csharp title='tests/CalculatorTests.cs'
[TestClass]
public class CalculatorTests
{
	[TestMethod]
	public int Sum_Should_ReturnTheSumOfTheTwoNumbers()
	{
		Calculator calculator = new();

		int result = calculator.Sum(2,3);

		Assert.AreEqual(expected: 5, actual: result);
	}
}
```

We don't know the method's implementation, but we wrote a test. We give it input data, and check the output.
For the other scenarios we haven't talked about yet, I find it a shame to stop there.
It's a personal feeling, but I find **white box testing** more relevant as a _mockist_.

So yeah, on the other hand, we thus have **white box testing**. At first sight, it is the same process: we give an input and check the output.
But we are also going to check what's going on _inside_ the SUT: check that it called its dependencies correctly, that the value has been correctly cached or saved in a repository, that an event has been emitted, etc.

This allows us to check each **behavior** and their **side effects**.

<AnchoredP id='how-to-write'>
	ðŸ”¸ The most awaited question ever... How do we write good unit tests?
</AnchoredP>

ðŸ”¹ I don't think there are good or bad unit tests... No, just joking!
You need to think on what to do before actually doing it. That can sound silly but just think before you do.
That's what I was explaining when I was talking about the fact that testing makes you better.
If you want to write efficient tests, you need to think on the way your components are going to communicate with each other.
Actually, your tests will be efficient once they are easy to do. And if you realize they are not, there is something wrong with your code.

eg: I've got a service that has to create a user. **Before writing my test**, I have to ask myself a few questions:
what is the responsability of my service? Is it responsible or sending an HTTP request to an external provider to get information?
Is it responsibile for database persistence? Is it responsible of the logging?

**Divider and Conquer**: a dependency here, one there, another there... Finally, what's left in your service?
The orchestration of a process delegated to different dependencies (eg: http client, repository, logger, etc.) and possibly a modification of the state of an entity. That's it.

In the end, a "good" test must:

-   protect you against regressions ;
-   be resistant to refactoring ;
-   give you a quick feedback ;
-   be maintainable.

<AnchoredP id='tips-to-start'>
	What about you give us some tips to start our journey?
</AnchoredP>

ðŸ”¹ I recommend people who want to start testing to start with the **Test Driven Development** approach.
Writing the test of a method after its implementation is not really the goal because you already know the implementation so your test will be highly coupled to your implementation.
In addition, your code already works so the test would probably be seen as a time loss. But above all: we don't benefit of any advantage of testing during the implementation phase.

You are not alone. There are tons of resources available to help you out.
Here are some books that I wish I have read early in my career:

-   "Test Driven Development - By Example" by Kent Beck ;
-   "Unit Testing - Principles, Practices and Patterns" by Vladimir Khorikov.

Ã‰galement, voici un site rempli de conseils et astuces sur TDD avec un grand nombre de katas pour progresser: [TDD Buddy](http://www.tddbuddy.com/).

En parlant de katas, faites des katas. Faites pleins de katas et faites en Ã  plusieurs (_pair_ et/ou _mob programming_) si vous en avez la possibilitÃ©. C'est fun et c'est trÃ¨s formatteur, notamment sur le fait de dÃ©marrer avec des exercices simples et progressivement augmenter la difficultÃ© jusqu'Ã  se retrouver avec des situations similaires Ã  ce que l'on peut trouver dans des projets rÃ©els. En plus de [TDD Buddy](http://www.tddbuddy.com/), je pourrais recommander [Code Wars](https://www.codewars.com/) si vous Ãªtes en manque d'inspiration.
Sans forcÃ©ment faire de l'auto-promotion, vous pouvez aussi trouver quelques katas sur mon [GitHub](https://github.com/Tr00d/).

Un dernier conseil pour dÃ©marrer le testing, on peut se rÃ©fÃ©rer Ã  ce qu'on appelle le triple A (AAA), qui signifie _Arrange, Act, Assert_, pour rendre les tests plus clairs et organisÃ©s. Le but est de diviser son test unitaire en 3 parties distinctes:

1. _arrange_ : c'est le scÃ©nario, la partie oÃ¹ tu prÃ©pares les donnÃ©es _input_ de ta mÃ©thode ;
2. _act_ : c'est l'action, le fait de rÃ©aliser l'appel Ã  la mÃ©thode que tu vas tester ;
3. _assert_ : c'est la vÃ©rification du _behavior_, lÃ  partie oÃ¹ tu vÃ©rifies l'_output_ ou les _side effects_.

<AnchoredP id='bad-smells'>
	ðŸ”¸ Quels sont les "bad smells" dans l'unit testing?
</AnchoredP>

ðŸ”¹ J'en vois quelques-uns...

-   une partie _arrange_ qui fait 15 lignes... C'est trop compliquÃ©. On voit clairement que la mÃ©thode testÃ©e fait trop de choses car le scÃ©nario est trop compliquÃ© Ã  mettre en place!
-   On dit qu'**un test ne doit avoir qu'une et une seule raison d'Ã©chouer**. Un test ne devrait contenir qu'un seul _assert_.
-   Le fait que tu aies du mal Ã  Ã©crire des tests unitaires, non pas Ã  cause du fait que tu n'aies pas la connaissance nÃ©cessaire mais plutÃ´t en rapport au code Ã  tester... c'est qu'il y a un soucis au niveau de ton composant. Alors, prends du recul et penses aux responsabilitÃ©s.

<AnchoredH2 id='to-go-further'>Pour aller plus loin</AnchoredH2>

<AnchoredP id='libraries'>
	ðŸ”¸ Tu as des librairies intÃ©ressantes en tÃªte pour faciliter le travail?
</AnchoredP>

ðŸ”¹ Oui. Pour moi, on peut considÃ©rer trois groupes de librairies:

1. les librairies de testing qui permettent de gÃ©nÃ©rer des tests ;
2. les librairies de mocking qui permettent de surcharger le comportement de tes dÃ©pendances et de les monitorer ;
3. les librairies de gÃ©nÃ©ration de donnÃ©es.

Pour ma part:

|                     **Frameworks de test**                     |                **Librairies de mocking**                 |          **Librairies de gÃ©nÃ©ration de donnÃ©es**           |
| :------------------------------------------------------------: | :------------------------------------------------------: | :--------------------------------------------------------: |
| [MSTest](https://www.nuget.org/packages/MSTest.TestFramework/) |        [Moq](https://www.nuget.org/packages/Moq/)        | [AutoFixture](https://www.nuget.org/packages/AutoFixture/) |
|         [NUnit](https://www.nuget.org/packages/NUnit/)         |    [NInject](https://www.nuget.org/packages/Ninject/)    |
|         [XUnit](https://www.nuget.org/packages/xunit/)         | [WireMock](https://www.nuget.org/packages/WireMock.Net/) |

ðŸ”¸ Sur ce point-ci particuliÃ¨rement, j'aimerais mettre en avant le fait qu'il existe aussi des librairies de test pour le _front-end_. En fait, le testing unitaire n'est pas rÃ©servÃ© aux dÃ©veloppeurs
_back-end_. On citera notamment [Jest](https://www.npmjs.com/package/jest), [Mocha](https://www.npmjs.com/package/mocha), [Cypress](https://www.npmjs.com/package/cypress) et [Jasmine](https://www.npmjs.com/package/jasmine) comme librairies fortement liÃ©es au testing dans des applications JavaScript.

<AnchoredP id='what-is-tdd'>
	ðŸ”¸ Du coup, tu n'arrÃªtes pas d'en parler. C'est quoi le{' '}
	<span style={{ fontStyle: 'italic' }}>Test Driven Development</span> (TDD)?
</AnchoredP>

ðŸ”¹ Je suis content que tu poses enfin la question! C'est pas comme si je t'avais tendu la perche plus d'une fois... C'est la joie, le bonheur, la rÃ©ponse ultime au sens de la vie, c'est tout Ã§a!
Non, je rigole. En fait, c'est une faÃ§on de mettre les tests au centre de ce que tu fais. On a parlÃ© de tous les points positifs de faire des tests unitaires et aussi du fait qu'on les perdait si on faisait les tests Ã  la fin sans forcÃ©ment aller dans le dÃ©tail.
En fait, la meilleure faÃ§on de bÃ©nÃ©ficier des avantages des tests, c'est de les faire en premier mais ce n'est pas que Ã§a. Ce n'est pas d'abord faire tous les tests puis ensuite faire l'implÃ©mentation.
Non, il y vraiment un aspect itÃ©ratif que l'on retrouve d'ailleurs dans l'AgilitÃ©. Tu y vas Ã©tape par Ã©tape (_baby steps_), tu ajoutes de nouveaux _behaviors_ en garantissant que ceux prÃ©cÃ©demment ajoutÃ©s fonctionnent toujours. Le filet de sÃ©curitÃ© s'agrandit petit Ã  petit naturellement.
On peut prÃ©senter cela diffÃ©remment: imaginons une Ã©chelle. Cela sera toujours plus facile de la monter marche par marche que de les monter trois par trois.

J'ajouterais que contrairement aux idÃ©es reÃ§ues, TDD ne rend pas la durÃ©e de dÃ©veloppement plus longue, bien au contraire. Par exemple, il n'est pas nÃ©cessaire d'exÃ©cuter la solution pour savoir que le code fonctionne car il a entiÃ¨rement Ã©tÃ© dÃ©veloppÃ© sur base de tests.

<Figure
	data={{
		src: '/img/test-driven-development.png',
		alt: 'Cycle du TDD',
		type: 'image',
		style: { border: '.5em solid black' },
	}}>
	Le cycle de dÃ©veloppement sous TDD
</Figure>

La premiÃ¨re Ã©tape, c'est l'Ã©criture d'**un** test unitaire. Normalement, ce test doit _obligatoirement_ Ã©chouer puisqu'aucune implÃ©mentation n'a Ã©tÃ© Ã©crite pour qu'il rÃ©ussise.
L'Ã©tape suivante, c'est donc d'Ã©crire le code qui permet de faire passer le test au vert. Et lÃ , c'est trÃ¨s important de savoir que ce passage de rouge vers le vert doit Ãªtre **le plus court possible**. C'est le moment oÃ¹ on Ã  le droit d'Ã©crire du code "moche", d'_hardcoder_ un rÃ©sultat, de dupliquer, de coller une rÃ©ponse de StackOverflow, etc. Cela peut paraÃ®tre bizarre au dÃ©but mais il y a un vrai intÃ©rÃªt: vÃ©rifier que l'ajout d'un nouveau _behavior_ est possible sans casser tout ce qui a Ã©tÃ© fait auparavant.
L'Ã©tape suivante, c'est le refactoring. On a fait un code horrible, il faut maintenant faire quelque chose de propre. J'ai parlÃ© plus tÃ´t de refactoring plus simple et sÃ©curisÃ©: on y est! On a notre _green light_ et le _behavior_ est garanti tant que cette _light_ reste _green_. On a notre _fast feedback loop_ Ã  portÃ©e de main (ou de clic, ou de raccourci) pour savoir si tout est ok. Tu me suis?
Ensuite, on atteint la fin du cycle. Cela veut dire une chose: on recommence.

ðŸ”¸ Je vais fournir un petit exemple pour que tout le monde se situe! Je vais faire Ã§a avec un calculateur de longueur de chaÃ®ne de caractÃ¨res tiens, c'est simple Ã  rÃ©aliser.
Donc, on commence par Ã©crire le test unitaire:

```csharp title='tests/StringCalculatorTests.cs'
[TestClass]
public class StringCalculatorTests
{
	[TestMethod]
	public int Length_ShouldReturn_CorrectLength()
	{
		StringCalculator calculator = new();

		int result = calculator.Length("string")

		Assert.AreEqual(expected: 6, actual: result);
	}
}
```

Le test Ã©choue parce que nous n'avons pas encore crÃ©Ã© la classe `StringCalculator`. Prochaine Ã©tape!

```csharp title='src/StringCalculator.cs'
public class StringCalculator
{
	public int Length (string str)
	{
		return 6;
	}
}
```

Ici, nous sommes donc Ã  l'Ã©tape verte. On doit donc passer Ã  l'Ã©tape bleue.

ðŸ”¹ J'ajouterais que ton code est super moche vu que tu as _hardcodÃ©_ la valeur. Mais c'est bien! C'est le but!

ðŸ”¸ La plus longue: rÃ©aliser un refactoring du code qui nous permet de rÃ©pondre au besoin demandÃ© (calculer la longueur d'une chaÃ®ne de caractÃ¨res) tout en ne cassant pas le test:

```csharp title='src/StringCalculator.cs'
public class StringCalculator
{
	public int Length (string str)
	{
		return str.Length;
	}
}
```

Et voilÃ ! Nous pouvons commencer l'Ã©criture d'un nouveau test unitaire.

ðŸ”¹ C'est un exemple assez simple mais tu y es. Il faut bien noter qu'il y a tout de mÃªme des rÃ¨gles Ã  respecter avec TDD mais je pourrais en parler pendant des heures alors on va s'arrÃªter ici!

<AnchoredP id='what-is-tcr'>
	ðŸ”¸ D'accord! D'ailleurs, j'ai ouÃ¯e dire que t'as rÃ©cemment appris le{' '}
	<span style={{ fontStyle: 'italic' }}>Test && Commit || Revert</span> (TCR).
	Tu sais expliquer en quoi Ã§a consiste?
</AnchoredP>

ðŸ”¹ Exact, j'ai eu la chance de prendre connaissance de cette pratique via un _workshop_. Pour schÃ©matiser, disons que c'est une vision extrÃªme de TDD. Le meilleur moyen de l'utiliser est avec un script sÃ©parÃ©.
Ce script va analyser ta solution Ã  chaque sauvegarde et va ensuite exÃ©cuter tous tes tests. Si tous tes tests sont vert, il crÃ©e un commit qui reprÃ©sente un Ã©tat stable de ta branche (Test && Commit).
Si tu as un seul test qui ne passe plus, il fait un rollback pour revenir Ã  l'Ã©tat du dernier commit (Revert), qui lui est stable.
Cela te force Ã  avancer en _baby steps_ et une chose est mise en Ã©vidence: c'est ton dernier changement qui a cassÃ© quelque chose.

Au dÃ©but, tu passes par une phase de frustration parce que tu peux perdre du code mais justement, cela t'incite Ã  avancer petit Ã  petit pour limiter tes pertes. Plus tes _steps_ sont petites, moins tu risques de perdre du code. C'est un super enseignement en complÃ©ment de TDD.
Losque tu deviens relativement Ã  l'aise avec tout Ã§a, tu remarques que tu avances de plus en plus vite et surtout, tu as toujours une branche qui fonctionne.

<AnchoredH2 id='conclusion'>Conclusion</AnchoredH2>

<AnchoredP>ðŸ”¸ Un dernier mot pour clÃ´turer cette interview?</AnchoredP>

ðŸ”¹ "Victoriae mundis et mundis lacrima", ca ne veut absolument rien dire mais je trouve que c'est assez dans le ton.
Plus sÃ©rieusement, Ã§a fait dÃ©jÃ  un moment qu'on discute mais on a seulement grattÃ© la surface. Il reste beaucoup de points Ã  aborder sur le testing. Je conseillerais donc vivement aux lecteurs d'Ãªtre curieux sur le sujet, de lire et surtout de pratiquer. N'hÃ©sitez pas Ã  demander de l'aide autour de vous.
Et sinon le testing, Ã§a vous tente?

<Figure
	data={{
		src: '/img/developers-deliver-working-solutions.jpg',
		alt: 'Developers deliver working solutions, not testable code',
		type: 'image',
		style: { width: '50%', border: '.1em grey solid' },
	}}
/>

<Newsletter url={MAILCHIMP_URL} />

export const toc = [
	{
		value: 'Presentation',
		id: 'presentation',
		children: [],
		level: 2,
	},
	{
		value: 'The topic',
		id: 'topic',
		children: [
			{
				value: 'First encounter',
				id: 'first-encounter',
				children: [],
				level: 3,
			},
			{
				value: 'What is it',
				id: 'what-is-it',
				children: [],
				level: 3,
			},
			{
				value: 'Where is it in the tests hierarchy',
				id: 'hierarchy-position',
				children: [],
				level: 3,
			},
			{
				value: 'Objective of unit testing',
				id: 'objective',
				children: [],
				level: 3,
			},
			{
				value: 'Pros and cons',
				id: 'pros-and-cons',
				children: [],
				level: 3,
			},
			{
				value: 'Test Coverage',
				id: 'test-coverage',
				children: [],
				level: 3,
			},
			{
				value: 'The cost',
				id: 'cost',
				children: [],
				level: 3,
			},
		],
		level: 2,
	},
	{
		value: 'In depth',
		id: 'details',
		children: [
			{
				value: 'Black box & white box, what is that',
				id: 'black-and-white-boxes',
				children: [],
				level: 3,
			},
			{
				value: 'How to write them efficiently',
				id: 'how-to-write',
				children: [],
				level: 3,
			},
			{
				value: 'Tips to start',
				id: 'tips-to-start',
				children: [],
				level: 3,
			},
			{
				value: 'Bad Smells',
				id: 'bad-smells',
				children: [],
				level: 3,
			},
		],
		level: 2,
	},
	{
		value: 'To go further',
		id: 'to-go-further',
		children: [
			{
				value: 'Librairies to simplify the work',
				id: 'libraries',
				children: [],
				level: 3,
			},
			{
				value: 'Test Driven Development',
				id: 'what-is-tdd',
				children: [],
				level: 3,
			},
			{
				value: 'Test && Commit || Revert ',
				id: 'what-is-tcr',
				children: [],
				level: 3,
			},
		],
		level: 2,
	},
	{
		value: 'Conclusion',
		id: 'conclusion',
		children: [],
		level: 2,
	},
];
