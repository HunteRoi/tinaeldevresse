---
slug: unit-testing
title: Les tests unitaires
tags: [test, test unitaire, programmation]
description: L'article du jour est fait en effort conjoint avec mon ancien collÃ¨gue et mentor <a href="https://www.linkedin.com/in/guillaumefaas/" target="_blank" rel="noreferrer noopener nofollow">Guillaume Faas</a> sous la forme d'une conversation entre 2 dÃ©veloppeurs. Joins-toi Ã  moi pour le remercier pour son incroyable implication dans l'Ã©criture de cet article! Nous espÃ©rons tous les 2 que tu vas l'adorer, autant que nous avons adorer l'Ã©crire!
image: img/unit-testing.jpg
---

import Figure from '../../../src/components/figure';
import SEO from '../../../src/components/seo';
import Reminder from '../../../src/components/reminder';
import Newsletter from '../../../src/components/newsletter';
import { MAILCHIMP_URL } from '../../../website_config.json';
import { AnchoredH2, AnchoredP } from '../../../src/components/AnchoredHeading';
import randomChoose from '../../../src/utils/randomChoose';

<a href='/blog/unit-testing'>
	<Figure
		data={{
			src: '/img/unit-testing.jpg',
			alt: 'Tests unitaires',
			type: 'image',
		}}
	/>
</a>

L'article du jour est fait en effort conjoint avec mon ancien collÃ¨gue et mentor <a href="https://www.linkedin.com/in/guillaumefaas/" target="_blank" rel="noreferrer noopener nofollow">Guillaume Faas</a>
(ğŸ”¹) sous la forme d'une conversation entre 2 dÃ©veloppeurs.

Joins-toi Ã  moi pour le remercier pour son incroyable implication dans l'Ã©criture de cet article! Nous espÃ©rons tous les 2 que tu vas l'adorer, autant que nous avons adorer l'Ã©crire.

<!--truncate-->

<SEO uri='blog/unit-testing' image='img/unit-testing.jpg' type='article' />

---

<Reminder />

---

_tldr; fais des katas en appliquant le Test Driven Development!_

<AnchoredH2 id='presentation'>PrÃ©sentation</AnchoredH2>

<AnchoredP>ğŸ”¸ Salut Guillaume! Tu sais te prÃ©senter s'il te plaÃ®t?</AnchoredP>

ğŸ”¹ Salut TinaÃ«l! Merci de m'avoir invitÃ© Ã  parler sur ton site. Mon nom est Guillaume Faas et je suis un expert .NET / Software Craftsman, actuellement employÃ© chez [Squaremiled S.A.](https://squaremiled.com/). Je dÃ©veloppe des logiciels depuis presque 10 ans, en ayant Ã©voluÃ© dans des environnements et secteurs d'activitÃ©s variÃ©s.

<AnchoredH2 id='topic'>Le sujet!</AnchoredH2>

<AnchoredP>ğŸ”¸ De quoi va-t-on parler aujourd'hui?</AnchoredP>

ğŸ”¹ On va parler de **test unitaire**! Qui l'eÃ»t cru?!

<AnchoredP id='first-encounter'>
	ğŸ”¸ Quand est-ce que t'y as touchÃ© pour la premiÃ¨re fois?
</AnchoredP>

ğŸ”¹ C'Ã©tait il y a longtemps. J'avais Ã  peine quelques annÃ©es d'expÃ©rience Ã  l'Ã©poque. J'Ã©tais employÃ© par la mÃªme sociÃ©tÃ© pendant une majeure partie de ma carriÃ¨re et, par rapport Ã  mon day-to-day, je pensais que j'avais dÃ©jÃ  tout vu.
En rÃ¨gle gÃ©nÃ©rale, lorsqu'on commence Ã  travailler pour la premiÃ¨re fois, on s'attend Ã  ce que les entreprises rÃ©alisent des produits dans les rÃ¨gles de l'art juste parce qu'il s'agit du milieu professionnel. Donc, notre premier rÃ©flexe n'Ã©tait pas de regarder ailleurs pour dÃ©couvrir d'autres pratiques.
Enfin, c'Ã©tait mon cas.

Revenons en au sujet principal! Je commenÃ§ais Ã  regarder des guidelines, des best-practices, des _patterns_, etc. Je suis tombÃ© sur plein de sujets excitants et surtout nouveaux. C'Ã©tait comme si j'avais mis les pieds dans un nouveau monde qui n'avait rien Ã  voir avec la routine dans laquelle j'Ã©tais ancrÃ©. Le _testing_ Ã©tait Ã©videmment l'un de ces sujets.
Evidemment, cela n'aura pas Ã©tÃ© une adoption immÃ©diate de ma part! Bien que je comprenais pourquoi le testing Ã©tait important ainsi que tous les bÃ©nÃ©fices associÃ©s, je pensais que c'Ã©tait trop dur parce que je ne voyais pas comment introduire des tests dans le projet sur lequel j'Ã©tais assignÃ©. Pour Ãªtre tout Ã  fait honnÃªte: OUI, c'Ã©tait dur.
Mais pas parce que c'Ã©tait du _testing_: le produit sur lequel je travaillais Ã©tait en fait un monolithe avec Ã©normÃ©ment de couplage et le testing aurait intÃ©grÃ© un (trop) gros refactoring.

Je savais que je devais d'abord apprendre des principes et des _patterns_ (principalement sur les faÃ§ons de construire une application maintenable) avant d'Ãªtre capable d'introduire des tests. Ã‡a m'a pris du temps avant que je ne sois vraiment apte Ã  travailler avec une approche test-driven.

<AnchoredP id='what-is-it'>
	ğŸ”¸ Ok! Par contre, histoire de ne pas perdre les lecteurs... tu sais expliquer
	ce qu'est test unitaire s'il te plaÃ®t?
</AnchoredP>

ğŸ”¹ Oui, bien sÃ»r! Un test unitaire, c'est un test qui vÃ©rifie un _unit of code_. La notion de _unit of code_ varie en fonction des Ã©coles de testing.
L'Ã©cole London (ou Mockist) vont voir cela comme le plus petit _chunk_, typiquement une classe ou une mÃ©thode.
Par contre, l'Ã©cole Detroit (ou Classicist) vont voir cela comme un ensemble de classes ou de mÃ©thodes. La variation tient surtout de la taille de ton SUT (System Under Test) et de la relation entre les diffÃ©rents collaborateurs.

Mais Ã  la fin, un test unitaire est simplement **un morceau de code qui valide qu'un autre morceau de code a le rÃ©sultat et/ou side-effect attendu par rapport Ã  un scÃ©nario donnÃ©**.

<AnchoredP id='hierarchy-position'>
	ğŸ”¸ D'accord, mais du coup, Ã§a se situe oÃ¹ dans la "hiÃ©rachie des tests"? Ne me
	dis pas Â« tout Ã  gauche Â» sinon je vais Ãªtre fÃ¢chÃ©!
</AnchoredP>

ğŸ”¹ Je vois que tu es observateur. En effet, sur ce schÃ©ma, Ã§a se situe tout Ã  fait Ã  gauche <img style={{ display: "inline" }} src="https://www.pinclipart.com/picdir/big/524-5246191_troll-face-meme-png-troll-face-clipart.png" width="16" height="16" />
mais la rÃ©ponse que tu attends, j'imagine que c'est pourquoi. Je suppose qu'ils ont suivi l'ordre de la pyamide de testing mais de gauche Ã  droite au lieux de bas en haut. Plus tu seras situÃ© vers la gauche, plus tes tests seront nombreux et rapides. La logique inverse est appliquÃ©e lorsque tu vas dans l'autre sens.

Nous, on se situe sur la partie "unit" puisque techniquement, il n'y a pas plus petit qu'un _unit_. On va absolument pas tester ce qu'il y a autour. Le test unitaire doit Ãªtre exÃ©cutÃ© de faÃ§on _standalone_ et tu dois te trouver dans un environnement _sandbox_.
C'est-Ã -dire que ton test unitaire n'a aucun impact sur l'extÃ©rieur du test, et si tu en lances plusieurs en parallÃ¨le, ils ne doivent pas avoir de side-effects les uns les autres.

Cela signifie donc que dans un test unitaire: on ne contacte pas de DB, on Ã©vite de faire une requÃªte HTTP, d'accÃ©der Ã  un fichier du systÃ¨me, etc. De la mÃªme faÃ§on, on ne va pas contacter les autres dÃ©pendances de la solution.
On reste vraiment "interne" Ã  la fonction.

<Figure
	data={{
		src: '/img/software-testing-types.png',
		alt: 'Types de Software Testing',
		type: 'image',
	}}
/>

Si je regarde l'image et que je parle de chaque point de la partie _functional testing_:

- l'_unit testing_, c'est vÃ©rifier qu'un composant fonctionne bien ;
- l'_integration testing_, c'est vÃ©rifier que certains composants fonctionnent bien entre eux ;
- et Ã§a continue ainsi en augmentant la portÃ©e des tests jusqu'Ã  l'_user acceptance testing_ qui consiste Ã  vÃ©rifier l'entiÃ¨retÃ© de l'application tout en Ã©vitant de contacter les dÃ©pendances externes (ex: des requÃªtes vers des fournisseurs de donnÃ©es extÃ©rieurs Ã  ton application).
  Ce qui signifie que l'on est sur le scope global de l'application et donc que potentiellement, on va aller jusqu'Ã  tester la base de donnÃ©es.

<AnchoredP>
	ğŸ”¸ D'accord! Mais pourquoi le testing, c'est pas rÃ©alisÃ© dans le monde
	professionnel? Aussi bien les tests unitaires que les tests d'intÃ©gration...
</AnchoredP>

ğŸ”¹ En rÃ©alitÃ©, la majeure partie des dÃ©veloppeurs n'Ã©crivent pas ou peu de tests. De plus, les tests d'intÃ©grations sont moins rÃ©pandus que les tests unitaires car ils sont plus complexes Ã  Ã©crire. Au final, cette tÃ¢che est souvent vue comme une corvÃ©e ou alors une extra-step que l'on fera uniquement si on a le temps.
Il est important de sÃ©parer test unitaire et test d'intÃ©gration car ils n'ont pas la mÃªme portÃ©e ni la mÃªme utilitÃ©.
Comme on en parlait avant, un test unitaire est _rapide_, il s'agit de notre _feedback loop_ la plus rapide. On va donc les executer souvent et il nous permettrons de savoir si un composant a subi une rÃ©gression.
Par contre, un test d'intÃ©gration sera plus lent mais couvrira un scope plus large et plus reprÃ©sentatif d'un environnement rÃ©el. Il aura donc plus de _valeur_. 
 
A noter qu'il n'y a pas d'obligation d'implÃ©menter les deux, on pourrait trÃ¨s bien avoir une _test suite_ composÃ©e uniquement de tests d'une seule de ces categories. Mais il convient de garder Ã  l'esprit que notre _test suite_ ne sera pas des plus efficaces.

<Figure
	data={{
		src: randomChoose(
			'https://miro.medium.com/max/600/1*xHibbXdcePT0GtpeZRgxSA.gif',
			'https://media4.giphy.com/media/hqq505vU9iHCOGySD5/giphy.gif',
			'https://media1.giphy.com/media/VXmWbcDSj2yqnsXUrF/giphy.gif'
		),
		alt: 'GIF on integration testing',
		type: 'image',
	}}
/>

<AnchoredP id='objective'>
	ğŸ”¸ C'est quoi le but du testing unitaire et quand est-ce que Ã§a devrait Ãªtre
	appliquÃ©?
</AnchoredP>

ğŸ”¹ Le but est assez simple: c'est de montrer qu'une mÃ©thode fonctionne comme tu l'attends. C'est-Ã -dire que tu vas avoir un comportement attendu, par exemple ta mÃ©thode `getSomething` doit te retourner quelque chose. Tu vas donc tester diffÃ©rents scÃ©narios et vÃ©rifier qu'elle se comporte toujours de la bonne faÃ§on.

Pour ce qui est du "quand", et bien c'est simple: Ã§a doit Ãªtre appliquÃ© Ã  partir du moment oÃ¹ tu as de la logique quelque part.

<AnchoredP id='pros-and-cons'>
	ğŸ”¸ Bah du coup, quels en sont les avantages et inconvÃ©nients de la mise en
	place de tests unitaires?
</AnchoredP>

ğŸ”¹ Comme dit prÃ©cÃ©demment, tu Ã©cris du code pour tester du code. Vu comme cela, on dirait surtout une charge de travail supplÃ©mentaire. Sauf qu'il existe de rÃ©els intÃ©rÃªts derriÃ¨re.

1. Une suite de tests devient ce qu'on appelle une **living documentation**.

    Lorsque l'on parle de documentation, on a tous Ã  l'esprit les commentaires ou XmlDocumentation. Le problÃ¨me est qu'ils ne sont jamais Ã  jour avec le reste du code. Le code Ã©volue, la documentation non. Par contre, ton test unitaire sera toujours up-to-date. Si ce n'est pas le cas, alors ta _test suite_ ne te donnera pas le feu vert pour aller plus loin.

    C'est d'autant plus intÃ©ressant dans le cadre d'une arrivÃ©e d'un nouveau dÃ©veloppeur sur le projet. PlutÃ´t que de lire tout le code d'une mÃ©thode pour savoir ce qu'elle fait, il lui suffit de regarder les diffÃ©rents tests de cette methode. Chaque comportement sera reprÃ©sentÃ© par un test avec un naming explicite sur le scÃ©nario et rÃ©sultat attendu. **Ã‡a facilite donc l'_onboarding_!**


2. Le test unitaire sert aussi de **filet de sÃ©curitÃ© contre la rÃ©gression**.

   Au bout d'un moment dans un projet, tu fais du _refactoring_. Et quand tu modifies du code, tu casses toujours un truc. C'est dÃ©jÃ  arrivÃ©, Ã§a arrivera encore.
   Mais ton test unitaire, il est lÃ . Au moment du _build_, si tu as cassÃ© quelque chose pendant ta refonte de code, ton test unitaire te le marque en rouge! Et Ã§a, pour un dÃ©veloppeur, c'est Ã©norme! Tu es beaucoup plus serein, et tu passes bien moins de temps Ã  vÃ©rifier que tes changements n'ont pas eu d'impacts sur le reste du code.
   Pas besoin de relancer la solution, pas besoin de vÃ©rifier chaque page de ton site, chaque bouton de ton application mobile, etc. Si tu es couvert par des tests unitaires, tu n'as pas peur du _refactoring_.

3. Ã‰crire des tests, Ã§a amÃ©liore forcÃ©ment la **stabilitÃ© du code** de ton application, ce qui produit par consÃ©quent **moins de bugs**.

4. Dans la continutÃ© du point prÃ©cÃ©dent, Ã§a **rÃ©duit le temps de dÃ©tection des bugs**. Mais Ã§a, on en parlera plus tard!

5. C'est pas rÃ©ellement un avantage direct, mais je pense que c'est important de le mentionner: **faire du testing unitaire te rend meilleur**.

   Pour faire en sorte que tu puisses Ã©crire des tests unitaires, tu dois respecter certains principes. Tu dois toujours avoir une certaine couche abstraction, pour _mocker_ tes dÃ©pendances, tu dois pouvoir les injecter,... en fait tu vas te forcer Ã  appliquer SOLID le plus souvent possible.
   Et du coup, Ã§a te force Ã  casser des composants, Ã  les dÃ©coupler, Ã  rÃ©flÃ©chir et Ã  prÃ©voir tout Ã§a. Chose que tu n'es pas obligÃ© de faire si tu ne fais pas de tests. Et donc, action-rÃ©action: tu deviens un meilleur dÃ©veloppeur.

6. Faire des tests unitaires prouve que, derriÃ¨re le projet, il y a un **objectif long terme**. En effet, la mise en place de tests, Ã§a demande une analyse rigoureuse des demandes du client ainsi que des _requirements_.
   Et tout Ã§a montre que le client est impliquÃ© dans le dÃ©veloppement du projet car il y a potentiellement un rÃ©el besoin.

ğŸ”¸ Et comme c'est peu mis en place dans les entreprises, c'est vu comme "nouveau" et Ã§a motive Ã  en apprendre plus!

ğŸ”¹ Ouais mais Ã§a, chacun peut le voir diffÃ©rement. Certains (comme toi) le voient comme quelque chose d'intÃ©ressant.
Dans un contexte un poil diffÃ©rent, d'autres pourraient le prendre comme une pression supplÃ©mentaire alors qu'ils sont dÃ©jÃ  sous l'eau.

Pour ce qui est des inconvÃ©nients, je dirais que:

1. il y a des prÃ©-requis: il faut des notions sur les principes de l'orientÃ© objet (et notamment l'abstraction), sur l'injection de dÃ©pendances, sur les principes [SOLID](https://www.digitalocean.com/community/conceptual_articles/s-o-l-i-d-the-first-five-principles-of-object-oriented-design)...
2. c'est flagrant mais il y a peu de personnes compÃ©tentes pour te coacher correctement sur le sujet.
3. il y a une courbe d'apprentissage/de progression assez importante. Si quelqu'un met 4 heures pour dÃ©velopper une fonctionnalitÃ©, cette mÃªme personne mettra probablement aussi 4 heures pour Ã©crire les tests.
4. Ã§a demande de la prÃ©paration : il faut rÃ©flÃ©chir Ã  l'architecture du projet, aux relations entre les diffÃ©rents composants, ...
5. il y a un manque de comprÃ©hension du cÃ´tÃ© des autres dÃ©partements (non-IT) sur le sujet.

On entend souvent dire que "Ã§a prend du temps et que Ã§a sera planifiÃ© plus tard" ou que "les dÃ©veloppeurs n'ont pas le temps" mais ces inconvÃ©nients n'en sont pas vraiment.
En effet, le premier indique clairement un manque de vision long terme sur le produit alors que le second indique un problÃ¨me d'organisation (les tests unitaires devraient Ãªtre inclus dans l'estimation de dÃ©veloppement d'une fonctionnalitÃ© et pas comme un travail supplÃ©mentaire Ã  rÃ©aliser).

<AnchoredP id='bugs-still-occur'>
	ğŸ”¸ Parfois, tu as quand mÃªme des problÃ¨mes qui surviennent dans des
	applications couvertes par des tests unitaires. Pourquoi?
</AnchoredP>

ğŸ”¹ Ã‰videmment, le risque zÃ©ro n'existe pas. Ta suite de tests peut avoir un scÃ©nario non-couvert.
Elle peut potentiellement laisser passer des choses parce que tu as soit oublier un test unitaire (un scÃ©nario que tu as oubliÃ© de prÃ©voir) soit une intÃ©gration qui se passe mal entre des composants.
C'est pas la mort hein!

Admettons: tu prends le cas d'un _refactoring_ qui te gÃ©nÃ¨re 10 bugs. Le mÃªme _refactoring_ couvert de tests unitaires te gÃ©nÃ¨re 1 bug. Il reste 1 bug, c'est pas terrible. Mais, Ã§a ira plus vite de rÃ©gler 1 bug que 10.

<AnchoredP id='test-coverage'>
	ğŸ”¸ Et le <span style={{ fontStyle: 'italic' }}>test coverage</span>, dans tout
	Ã§a?
</AnchoredP>

ğŸ”¹ Donc d'accord, le test unitaire n'a pas rÃ©ponse Ã  tout. Et c'est lÃ  qu'on arrive sur le _coverage_. C'est une mÃ©trique informative sur la progression de couverture de tests de ton application.
Cependant, c'est mal de mesurer la qualitÃ© de la suite de tests sur base de sa couverture. Tu peux avoir un _coverage_ Ã  100% avec absolument rien qui est testÃ©. Il suffit de faire uniquement des tests qui ne vÃ©rifient rien, ou qui font des vÃ©rifications bidons (0 est Ã©gal Ã  0 â†’ toujours vrai).
Tu as un coverage complet, mais la stabilitÃ© de ton application n'est absolument pas vÃ©rifiÃ©e.

Le seul moyen de vÃ©rifier la qualitÃ© d'une suite unitaire d'un projet, c'est de se poser quelques questions:

- est-ce que le temps de dÃ©veloppement gÃ©nÃ©ral des fonctionnalitÃ©s diminue?
- est-ce que la quantitÃ© de bugs trouvÃ©s en production diminue?
- est-ce que tu arrives Ã  facilement accueillir une nouvelle ressource au sein de l'Ã©quipe de dÃ©veloppement?
- est-ce que les dÃ©veloppeurs ont confiance en leur code quand ils terminent une fonctionnalitÃ©?

Le soucis, c'est que c'est dur de faire de la mÃ©trique sur tous ces points...

<AnchoredP id='cost'>
	ğŸ”¸ Bon sinon... question coÃ»t, qu'est-ce qu'il en est? Parce que finalement,
	Ã©crire un test unitaire, c'est tout de mÃªme Ã©crire du code. Ã‡a coÃ»te!
</AnchoredP>

ğŸ”¹ Oui et non. Ã‡a va dÃ©pendre de ton contexte, mais je ne pense pas que l'on devrait les compter dans le budget. Ou du moins, on ne devrait pas les voir comme une charge supplÃ©mentaire parce qu'ils te font gagner Ã©normÃ©ment de temps sur le long terme.
Donc ta stratÃ©gie de projet va dÃ©pendre de comment tu vois ces tests unitaires, mais de mon point de vue, c'est un **Ã©norme** gain de temps!

C'est sÃ»r que dÃ©velopper une fonctionnalitÃ© va te prendre un peu plus de temps (et encore! Ã§a va dÃ©pendre des personnes et de leur degrÃ© d'affinitÃ© avec Ã§a), mais d'un autre cÃ´tÃ©, Ã§a va te "sauver la vie" pas mal de fois parce que tu vas Ã©viter Ã©normement de bugs qui, en temps normal,
seraient arrivÃ©s bien plus tard dans ton _process_ (que Ã§a soit lors des tests utilisateur sur un environnement de QA ou en production). Et **plus un bug est dÃ©couvert tard, plus il coÃ»te cher**:

<Figure
	data={{
		src: 'https://assets.deepsource.io/995f56d/images/blog/cost-of-fixing-bugs/chart.jpg',
		alt: 'CoÃ»t de correction des bugs',
		type: 'image',
		url: 'https://deepsource.io/blog/exponential-cost-of-fixing-bugs/',
	}}
>
	Le coÃ»t de correction d'un bug sur base du moment oÃ¹ il a Ã©tÃ© dÃ©tectÃ©, sourcÃ©
	chez{' '}
	<a href='https://deepsource.io/blog/exponential-cost-of-fixing-bugs/'>
		DeepSource
	</a>
	!
</Figure>

C'est normal: un bug dÃ©couvert par un test unitaire, il est dÃ©couvert directement sur ta machine, en local. Tu le corriges toi-mÃªme et c'est terminÃ©.

A contrario, un bug qui passe en production... il est dÃ©couvert par un utilisateur qui doit ouvrir un ticket. Ce ticket, il va Ãªtre gÃ©rer par ton _Product Owner_. Il va Ãªtre inclus
dans un _sprint_, puis il sera assignÃ© Ã  un dÃ©veloppeur. Ensuite, il va y avoir une phase d'investigation (reproduction du bug), une phase de correction de bug et aprÃ¨s
Ã§a doit repartir sur tous les environnements et Ãªtre validÃ© par des _Quality Assurance Users_.

Alors qu'un test en quelques lignes de code aurait empÃªchÃ© tout Ã§a.

_ndlr: pour en savoir plus sur les raisons qui font qu'un logiciel a des bugs, n'hÃ©sitez pas Ã  consulter [cette page](https://www.softwaretestinghelp.com/why-does-software-have-bugs) et [d'autres sur le web](https://www.google.com/search?q=why+do+softwares+have+bugs)!_

<AnchoredH2 id='details'>En dÃ©tails</AnchoredH2>

<AnchoredP id='black-and-white-boxes'>
	ğŸ”¸ Ok! Et si on parlait maintenant de{' '}
	<span style={{ fontStyle: 'italic' }}>black box</span> et{' '}
	<span style={{ fontStyle: 'italic' }}>white box testing</span>?
</AnchoredP>

ğŸ”¹ C'est le moment pour moi de montrer mes talents insoupÃ§onnÃ©s de dessinateur!

<Figure
	data={{
		src: '/img/black-white-box-testing.png',
		alt: 'Black and white box testing',
		type: 'image',
		style: { border: '.5em solid black' },
	}}
>
	Les diffÃ©rences entre _black & white box testing_
</Figure>

Le **black box testing**, c'est donner une information d'entrÃ©e Ã  l'_unit of code_, et vÃ©rifier l'information de sortie. C'est aussi simple que Ã§a: on ne prend pas en compte ce qu'il se passe Ã  l'intÃ©rieur de la mÃ©thode.
C'est pas mal, c'est un dÃ©but, mais je trouve que c'est dommage de s'arrÃªter lÃ . C'est typiquement le genre de tests ajoutÃ©s en cours de route sur une application _legacy_ oÃ¹ c'est compliquÃ© de vÃ©rifier tout ce qu'il se passe parce qu'il y a dÃ©jÃ  beaucoup.

Prenons par exemple une mÃ©thode `Sum` d'une classe `Calculator`. Cette classe n'a pas de dÃ©pendance. Le test sur une mÃ©thode pure (sans dÃ©pendance ou qui n'accÃ¨de qu'Ã  des variables partagÃ©es) est obligatoirement un _black box test_:

```csharp title='tests/CalculatorTests.cs'
[TestClass]
public class CalculatorTests
{
	[TestMethod]
	public int Sum_Should_ReturnTheSumOfTheTwoNumbers()
	{
		Calculator calculator = new();

		int result = calculator.Sum(2,3);

		Assert.AreEqual(expected: 5, actual: result);
	}
}
```

On ne connaÃ®t pas l'implÃ©mentation de la mÃ©thode, mais on a Ã©crit un test. On lui donne des valeurs en entrÃ©e, et on vÃ©rifie la valeur de sortie.

De l'autre cÃ´tÃ©, on a le **white box testing**. C'est concrÃ¨tement la mÃªme chose: on donne un _input_ et on vÃ©rifie l'_output_ (c'est le but d'un test unitaire, finalement). Mais on va aussi vÃ©rifier ce qu'il se passe Ã  l'intÃ©rieur de l'_unit of code_.
Et donc potentiellement vÃ©rifier que ta mÃ©thode a bien fait appel Ã  sa dÃ©pendance, que la valeur a bien Ã©tÃ© mise dans un cache, sauvegardÃ©e dans un repo, qu'un event a bien Ã©tÃ© Ã©mis, etc. et lÃ , tout de suite, Ã§a donne plus de valeurs Ã  ton test.
Parce qu'on va dÃ©finir le _behavior_ de ton test de faÃ§on plus prÃ©cise, plus complÃ¨te, en vÃ©rifiant ce qu'il se passe Ã  l'intÃ©rieur.

<AnchoredP id='why-not-popular'>
	ğŸ”¸ Ah d'accord! Mais du coup, pourquoi est-ce que ce n'est pas plus adoptÃ© par
	les dÃ©veloppeurs?
</AnchoredP>

ğŸ”¹ C'est vraiment une interprÃ©tation personnelle parce que je ne dÃ©tiens pas la sainte vÃ©ritÃ©.
Je pense que dans notre cas, malgrÃ© le fait que l'on fasse du dÃ©veloppement de logiciels depuis plusieurs dÃ©cennies, on n'est pas encore sur un dÃ©veloppement logiciel "mature": si tu regardes en dÃ©tails, tu verras exactement les mÃªmes problÃ¨mes dans tous les projets sur lesquels on peut travailler.
Rajoute Ã  Ã§a le fait que le testing unitaire n'est pas forcÃ©ment (bien) enseignÃ© quand on est Ã  l'Ã©cole, et de ce fait pas appliquÃ© en entreprise.

Par consÃ©quent, tu n'as pas d'apprentissage continu sur le sujet, et donc tu tombes dans un cercle vicieux : personne n'en fait donc personne n'en fait.
Puis, combien de fois n'as-tu pas entendu "on fera les tests Ã  la fin" quand tu proposes d'en faire? Alors que faire Ã§a, c'est perdre pratiquement tous les avantages!

<AnchoredP>
	ğŸ”¸ Personnellement, j'ai eu la chance de faire mes Ã©tudes dans une institution
	qui tenait Ã  coeur d'enseigner en Ã©tant alignÃ©e avec le monde professionel
	mais aussi vis-Ã -vis des nouvelles technologies. Et pourtant, nous n'avons eu
	qu'une introduction aux tests unitaires. En tant qu'Ã©tudiant, Ã§a te tombe
	dessus et tu n'as pas forcÃ©ment le bagage nÃ©cessaire pour comprendre tout ce
	que l'on te demande. Pour ma part, Ã  l'Ã©poque, je n'avais absolument pas
	compris l'utilitÃ© du testing unitaire, et j'avais bÃ¢clÃ© la question Ã 
	l'examen!
</AnchoredP>

ğŸ”¹ La nivellation par le bas est perpÃ©tuelle. C'est d'autant plus embÃªtant pour les gens qui sont de bonne volontÃ© et qui veulent mettre des tests unitaires en place.
Dans l'industrie (sauf sur les projets qui sont chapeautÃ©s par des boÃ®tes qui ont plutÃ´t bonne conscience), tu vas Ãªtre fortement incitÃ© Ã  faire du _quick and dirty_.
Le problÃ¨me, c'est que tu es sur des solutions qui n'ont dÃ©jÃ  pas de tests unitaires. Comme je le disais avant, quand tu n'as pas de tests et que ton systÃ¨me grandit Ã  tous les niveaux:

- tes dÃ©veloppements te prennent beaucoup plus de temps ;
- t'as de plus en plus de bugs Ã  rÃ©gler ;
- comme Ã§a te gÃ©nÃ¨re plus de bugs, t'as plus de travail et donc t'as moins de temps pour Ã©crire des tests sur ta solution existante...

  ...en sachant qu'il y a une courbe de progression. Tu ne peux pas dire Ã  ton Ã©quipe du jour au lendemain : "allez hop, aujourd'hui tout le monde Ã©crit des tests unitaires" et t'as 100% de coverage. Ã‡a, Ã§a n'existe pas.

Tu es dÃ©jÃ  sur un flux tendu parce que tu n'as pas fait tes tests en amont, ce qui fait que tu te tapes toutes les consÃ©quences dans la figure.
Et donc, inciter une adoption aux tests unitaires et Ã  TDD devient d'autant plus compliquÃ© parce que les gens sont dÃ©jÃ  totalement noyÃ©s.

<AnchoredP id='how-to-write'>
	ğŸ”¸ La question que tous se posent... Comment Ã©crire de bons tests unitaires?
</AnchoredP>

ğŸ”¹ Il faut rÃ©flÃ©chir avant sur ce que tu veux faire. Ca peut paraÃ®tre bÃªte, mais _think before you do_. Quand j'expliquais que les tests unitaires te rendent meilleurs, c'est parce qu'ils te forcent Ã  rÃ©flÃ©chir sur les relations entre tes composants.
Si tu veux faire des tests unitaires efficaces, alors il faut rÃ©flÃ©chir sur comment tes composants vont communiquer entre eux. En fait, tes tests seront efficaces Ã  partir du moment oÃ¹ ils seront faciles Ã  faire. Et si tu te rends compte qu'ils ne le sont pas, c'est qu'il y a un soucis dans ton code.

Exemple: j'ai un _command handler_ qui doit me crÃ©er une utilisateur dans une base de donnÃ©es. **Avant d'Ã©crire mon test**, je dois rÃ©flÃ©chir: qu'est-ce que je veux que mon _handler_ fasse et ne fasse pas?
Est-ce que je veux que mon _handler_ envoie une requÃªte HTTP Ã  un fournisseur externe pour rÃ©cupÃ©rer des informations? Est-ce que je veux que Ã§a soit directement lui qui fasse la sauvegarde en DB? Est-ce que je veux que Ã§a soit lui qui s'occupe du logging dans un fichier? Peut-Ãªtre pas.
Une dÃ©pendance ici, lÃ , et lÃ ... Au final, qu'est-ce qu'il reste dans mon _command handler_ ? L'exÃ©cution des diffÃ©rentes dÃ©pendances, peut-Ãªtre une modification du statut de l'Ã©tat d'une entitÃ©, et voilÃ .

Mais finalement, un test unitaire efficace, c'est un test qui est fiable qui apporte de la valeur Ã  ta solution et qui te protÃ¨ge des effets de bord pour plus tard. C'est ainsi qu'on mesure l'efficacitÃ© de ta suite de tests.

<AnchoredH2 id='more-stuff'>Pour aller plus loin</AnchoredH2>

<AnchoredP id='libraries'>
	ğŸ”¸ Tu as des librairies intÃ©ressantes en tÃªte pour faciliter le travail?
</AnchoredP>

ğŸ”¹ Oui. Pour moi, il faut considÃ©rer deux groupes de librairies:

1. les librairies de testing, qui permettent de gÃ©nÃ©rer des tests unitaires. Mais je pense que ce sont vraiment des choix personnels.
2. les librairies de mocking, qui permettent de surcharger le comportement de tes dÃ©pendances et notamment de les monitorer. Mais c'est pareil, c'est trÃ¨s subjectif.

Pour ma part:

|                     **Frameworks de test**                     |                 **Librairies de mocking**                  |
| :------------------------------------------------------------: | :--------------------------------------------------------: |
| [MSTest](https://www.nuget.org/packages/MSTest.TestFramework/) |         [Moq](https://www.nuget.org/packages/Moq/)         |
|         [NUnit](https://www.nuget.org/packages/NUnit/)         |     [NInject](https://www.nuget.org/packages/Ninject/)     |
|         [XUnit](https://www.nuget.org/packages/xunit/)         | [AutoFixture](https://www.nuget.org/packages/AutoFixture/) |
|                                                                |  [WireMock](https://www.nuget.org/packages/WireMock.Net/)  |

ğŸ”¸ Sur ce point-ci particuliÃ¨rement, j'aimerais mettre en avant le fait qu'il existe aussi des librairies de test pour le _front-end_. En fait, le testing unitaire n'est pas rÃ©servÃ© aux dÃ©veloppeurs
_back-end_. On citera notamment [Jest](https://www.npmjs.com/package/jest), [Mocha](https://www.npmjs.com/package/mocha), [Cypress](https://www.npmjs.com/package/cypress) et [Jasmine](https://www.npmjs.com/package/jasmine) comme librairies fortement liÃ©es au testing dans des applications JavaScript.

<AnchoredP id='tips-to-start'>
	ğŸ”¸ T'as des conseils pour se lancer dans le testing unitaire?
</AnchoredP>

ğŸ”¹ Je recommande aux personnes qui veulent faire du testing unitaire de commencer avec TDD. Il n'y a pas meilleur pied Ã  l'Ã©trier parce que c'est vraiment lÃ  que tu vas mettre ton _behavior_ en avant.
Faire ton test aprÃ¨s l'implÃ©mentation, c'est pas objectif car tu connais dÃ©jÃ  l'implÃ©mentation donc ton test est fortement liÃ© Ã  ton implÃ©mentation. Ce qui n'est pas forcÃ©ment le cas avec TDD (que Ã§a soit du _black_ ou du _white box testing_), tu peux avoir une infinitÃ© de tests diffÃ©rents.

Un autre conseil, c'est de les faire. Vraiment. De faire l'effort de les commencer et de les terminer!
Et Ãªtre critique vis-Ã -vis de son code. Si c'est compliquÃ© de tester, ce n'est pas Ã  cause des tests, mais probablement Ã  cause de la maniÃ¨re dont ton projet est structurÃ©.

Et comme dernier conseil, je dirais: fais des katas. Fais plein de katas en TDD et fais-en Ã  plusieurs. C'est trÃ¨s formateur! Tu peux en trouver plein sur [Code Wars](https://www.codewars.com/) et [TDD Buddy](http://www.tddbuddy.com/).

Et concernant la maniÃ¨re dont on les Ã©crit, on peut se rÃ©fÃ©rer Ã  ce qu'on appelle le triple A (AAA), qui signifie _Arrange, Act, Assert_. En gros, c'est diviser son test unitaire en 3 parties distinces:

1. _arrange_ : la partie oÃ¹ tu prÃ©pares les donnÃ©es _input_ de ta mÃ©thode.
2. _act_ : le fait de rÃ©aliser l'appel Ã  la mÃ©thode que tu vas tester.
3. _assert_ : le moment de vÃ©ritÃ©, c'est-Ã -dire la partie oÃ¹ tu vas vÃ©rifier l'_output_ de ta mÃ©thode.

<AnchoredP id='what-is-tdd'>
	ğŸ”¸ Du coup, tu n'arrÃªtes pas d'en parler. C'est quoi le{' '}
	<span style={{ fontStyle: 'italic' }}>Test Driven Development</span> (TDD)?
</AnchoredP>

ğŸ”¹ C'est la vie, la joie, le bonheur, c'est tout Ã§a! Non, je rigole. En fait, c'est une faÃ§on de mettre les tests au centre de ce que tu fais. On a parlÃ© de tous les points positifs de faire des tests unitaires, et on a aussi parlÃ© du fait qu'on les perdait si on faisait les tests Ã  la fin.
En fait, la meilleure faÃ§on de bÃ©nÃ©ficier des avantages des tests, c'est de les faire au dÃ©but d'un projet. Ce n'est pas que Ã§a. Ce n'est pas d'abord faire tous les tests puis ensuite faire l'implÃ©mentation. Non, il y vraiment un cÃ´tÃ© incrÃ©mental. Tu y vas Ã©tape par Ã©tape en faisant en sorte qu'Ã  chaque fois que tu avances, tu utilises tous les tests que tu as fait avant comme filet de sÃ©curitÃ© qui s'agrandit petit Ã  petit.
C'est plus facile de monter une Ã©chelle oÃ¹ chaque marche fait 10cm que de monter une Ã©chelle oÃ¹ chaque marche fait 1m.

<Figure
	data={{
		src: '/img/test-driven-development.png',
		alt: 'Black and white box testing',
		type: 'image',
		style: { border: '.5em solid black' },
	}}
>
	Le cycle de dÃ©veloppement sous TDD
</Figure>

La premiÃ¨re Ã©tape, c'est d'Ã©crire **un** test unitaire. Normalement, ce test doit _obligatoirement_ Ã©chouÃ© d'emblÃ©e, puisqu'aucune autre ligne de code n'a Ã©tÃ© Ã©crite pour qu'il rÃ©ussise (deuxiÃ¨me Ã©tape).
L'Ã©tape suivante, c'est donc d'Ã©crire le code qui permet de faire passer le test au vert. Et lÃ , c'est trÃ¨s important de savoir que ce passage de rouge vers le vert doit Ãªtre **le plus court possible**. Il ne faut Ã©crire que le code qui fait passer le test au vert, ni plus ni moins.
L'Ã©tape suivante, c'est de modifier le code afin qu'il s'adapte au mieux aux _requirements_ du projet.

ğŸ”¸ Je vais fournir un petit exemple pour que tout le monde se situe! Je vais faire Ã§a avec un calculateur de longueur de chaÃ®ne de caractÃ¨res tiens, c'est simple Ã  rÃ©aliser.
Donc, on commence par Ã©crire le test unitaire:

```csharp title='tests/StringCalculatorTests.cs'
[TestClass]
public class StringCalculatorTests
{
	[TestMethod]
	public int Length_ShouldReturn_CorrectLength()
	{
		StringCalculator calculator = new();

		int result = calculator.Length("string")

		Assert.AreEqual(expected: 6, actual: result);
	}
}
```

Le test Ã©choue parce que nous n'avons pas encore crÃ©Ã© la classe `StringCalculator`. Prochaine Ã©tape!

```csharp title='src/StringCalculator.cs'
public class StringCalculator
{
	public int Length (string str)
	{
		return 6;
	}
}
```

Ici, nous sommes donc Ã  l'Ã©tape verte. On doit donc passer Ã  l'Ã©tape bleue. La plus longue: rÃ©aliser un refactoring du code qui nous permet de rÃ©pondre au besoin demandÃ© (calculer la longueur d'une chaÃ®ne de caractÃ¨res) tout en ne cassant pas le test:

```csharp title='src/StringCalculator.cs'
public class StringCalculator
{
	public int Length (string str)
	{
		return str.Length;
	}
}
```

Et voilÃ ! Nous pouvons commencer l'Ã©criture d'un nouveau test unitaire.

ğŸ”¹ C'est un exemple assez simple mais tu y es. Il faut bien noter qu'il y a des rÃ¨gles dans le TDD, mais on peut en parler pendant des heures alors on va s'arrÃªter ici!

<AnchoredP id='what-is-tcr'>
	ğŸ”¸ D'accord! D'ailleurs, j'ai ouÃ¯e dire que t'as rÃ©cemment appris le{' '}
	<span style={{ fontStyle: 'italic' }}>Test && Commit || Revert</span> (TCR).
	Tu sais expliquer en quoi Ã§a consiste?
</AnchoredP>

ğŸ”¹ Alors grosso modo, TCR, c'est une facon d'aller plus loin avec TDD. Le meilleur moyen d'utiliser Ã§a est avec un script sÃ©parÃ©.
Ce script va analyser ta solution Ã  chaque sauvegarde, et va exÃ©cuter tous tes tests. Si tous tes tests sont vert, il crÃ©e un commit qui represente un Ã©tat stable de ta branche (Test && Commit).
Si tu as un seul test qui foire, il fait un rollback pour revenir Ã  l'Ã©tat du dernier commit, stable du coup (Revert).
Ã‡a te force Ã  avancer en _baby steps_ et Ã§a part du principe que c'est ton dernier changement qui t'a fait foirer le truc.

Tu passes par une pÃ©riode de frustration parce que tu peux perdre du code mais justement, Ã§a t'incite Ã  avancer petit Ã  petit pour limiter tes pertes. C'est un super enseignement pour TDD.
Et quand tu es relativement Ã  l'aise avec tout Ã§a, Ã§a te fait aller plus vite car tu as toujours une branche qui fonctionne.

<AnchoredP id='bad-smells'>
	ğŸ”¸ Quels sont les "bad smells" dans l'unit testing?
</AnchoredP>

ğŸ”¹ Il y en a quelques-uns...

- Typiquement, le fait que la partie _arrange_ fasse 15 lignes... C'est trop compliquÃ©. On voit clairement que la mÃ©thode testÃ©e fait trop de choses!
- On dit qu'**un test ne doit avoir qu'une et une seule raison d'Ã©chouer**. Donc ton test ne doit contenir qu'un seul _assert_.
- Le fait que tu aies du mal Ã  Ã©crire des tests unitaires, non pas Ã  cause du fait que tu n'aies pas la connaissance nÃ©cessaire mais plutÃ´t en rapport au code Ã  tester... c'est qu'il y a un soucis au niveau de ton composant.
  Alors, repense Ã  ton architecture, repense Ã  tes liens.

<AnchoredH2 id='conclusion'>Conclusion</AnchoredH2>

<AnchoredP>ğŸ”¸ Un dernier mot pour clÃ´turer cette interview?</AnchoredP>

ğŸ”¹ J'ai une question Ã  poser aux lecteurs du coup... Vous allez en faire oui ou merde?

<Figure
	data={{
		src: '/img/developers-deliver-working-solutions.jpg',
		alt: 'Developers deliver working solutions, not testable code',
		type: 'image',
		style: { width: '50%', border: '.1em grey solid' },
	}}
/>

<Newsletter url={MAILCHIMP_URL} />

export const toc = [
	{
		value: 'PrÃ©sentation',
		id: 'presentation',
		children: [],
		level: 2,
	},
	{
		value: 'Le sujet',
		id: 'topic',
		children: [
			{
				value: 'PremiÃ¨re rencontre',
				id: 'first-encounter',
				children: [],
				level: 3,
			},
			{
				value: "Qu'est-ce que c'est",
				id: 'what-is-it',
				children: [],
				level: 3,
			},
			{
				value: 'OÃ¹ Ã§a se situe dans la "hiÃ©rarchie des tests"',
				id: 'hierarchy-position',
				children: [],
				level: 3,
			},
			{
				value: 'But du testing unitaire',
				id: 'objective',
				children: [],
				level: 3,
			},
			{
				value: 'Avantages et inconvÃ©nients',
				id: 'pros-and-cons',
				children: [],
				level: 3,
			},
			{
				value: 'Y toujours des bugs',
				id: 'bugs-still-occur',
				children: [],
				level: 3,
			},
			{
				value: 'Test Coverage',
				id: 'test-coverage',
				children: [],
				level: 3,
			},
			{
				value: 'Le coÃ»t',
				id: 'cost',
				children: [],
				level: 3,
			},
		],
		level: 2,
	},
	{
		value: 'Plus en dÃ©tails',
		id: 'details',
		children: [
			{
				value: 'Black box & white box, kÃ©sako',
				id: 'black-and-white-boxes',
				children: [],
				level: 3,
			},
			{
				value: 'ProblÃ¨me de popularitÃ©',
				id: 'why-not-popular',
				children: [],
				level: 3,
			},
			{
				value: 'Comment en Ã©crire efficacement',
				id: 'how-to-write',
				children: [],
				level: 3,
			},
		],
		level: 2,
	},
	{
		value: 'Pour aller plus loin',
		id: 'more-stuff',
		children: [
			{
				value: "Librairies facilitant l'implÃ©mentation",
				id: 'libraries',
				children: [],
				level: 3,
			},
			{
				value: 'Tips pour se lancer',
				id: 'tips-to-start',
				children: [],
				level: 3,
			},
			{
				value: 'Le Test Driven Development',
				id: 'what-is-tdd',
				children: [],
				level: 3,
			},
			{
				value: 'Le Test && Commit || Revert ',
				id: 'what-is-tcr',
				children: [],
				level: 3,
			},
			{
				value: 'Les "Bad Smells"',
				id: 'bad-smells',
				children: [],
				level: 3,
			},
		],
		level: 2,
	},
	{
		value: 'Conclusion',
		id: 'conclusion',
		children: [],
		level: 2,
	},
];
