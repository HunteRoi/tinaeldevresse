---
slug: unit-testing
title: Les tests unitaires
tags: [test, test unitaire, programmation]
description: L'article du jour est fait en effort conjoint avec mon ancien collÃ¨gue et mentor <a href="https://www.linkedin.com/in/guillaumefaas/" target="_blank" rel="noreferrer noopener nofollow">Guillaume Faas</a> sous la forme d'une conversation entre 2 dÃ©veloppeurs. Joins-toi Ã  moi pour le remercier pour son incroyable implication dans l'Ã©criture de cet article! Nous espÃ©rons tous les 2 que tu vas l'adorer, autant que nous avons adorer l'Ã©crire!
image: img/unit-testing.jpg
---

import Figure from '../../../src/components/figure';
import SEO from '../../../src/components/seo';
import Reminder from '../../../src/components/reminder';
import Newsletter from '../../../src/components/newsletter';
import { MAILCHIMP_URL } from '../../../website_config.json';
import { AnchoredH2, AnchoredP } from '../../../src/components/AnchoredHeading';
import randomChoose from '../../../src/utils/randomChoose';

<a href='/blog/unit-testing'>
	<Figure
		data={{
			src: '/img/unit-testing.jpg',
			alt: 'Tests unitaires',
			type: 'image',
		}}
	/>
</a>

L'article du jour est fait en effort conjoint avec mon ancien collÃ¨gue et mentor <a href="https://www.linkedin.com/in/guillaumefaas/" target="_blank" rel="noreferrer noopener nofollow">Guillaume Faas</a>
(ğŸ”¹) sous la forme d'une conversation entre 2 dÃ©veloppeurs.

Joins-toi Ã  moi pour le remercier pour son incroyable implication dans l'Ã©criture de cet article! Nous espÃ©rons tous les 2 que tu vas l'adorer, autant que nous avons adorer l'Ã©crire.

<!--truncate-->

<SEO uri='blog/unit-testing' image='img/unit-testing.jpg' type='article' />

---

<Reminder />

---

_tldr; fais des katas en appliquant le Test Driven Development!_

<AnchoredH2 id='presentation'>PrÃ©sentation</AnchoredH2>

<AnchoredP>ğŸ”¸ Salut Guillaume! Tu sais te prÃ©senter s'il te plaÃ®t?</AnchoredP>

ğŸ”¹ Salut TinaÃ«l! Merci de m'avoir invitÃ© Ã  parler sur ton site. Mon nom est Guillaume Faas et je suis un expert .NET / Software Craftsman, employÃ© chez Squaremiled S.A. Je construis des logiciels depuis presque 10 ans, dans des environnements et secteurs business variÃ©s.

<AnchoredH2 id='topic'>Le sujet!</AnchoredH2>

<AnchoredP>ğŸ”¸ De quoi va-t-on parler aujourd'hui?</AnchoredP>

ğŸ”¹ On va parler de **test unitaire**! Qui l'eÃ»t cru?!

<AnchoredP id='first-encounter'>
	ğŸ”¸ Quand est-ce que t'y as touchÃ© pour la premiÃ¨re fois?
</AnchoredP>

ğŸ”¹ C'Ã©tait il y a longtemps. Je pense que j'avais 3-4 ans d'expÃ©rience Ã  l'Ã©poque. J'ai travaillÃ© pour la mÃªme compagnie durant une grosse partie de ma carriÃ¨re et, par rapport Ã  mon job habituel lÃ -bas, je pensais que j'avais tout vu.
En rÃ¨gle gÃ©nÃ©rale, lorsqu'on commence Ã  travailler pour la premiÃ¨re fois, on s'attend Ã  ce que les entreprises fassent des produits Ã  la pointe, juste parce qu'ils sont professionnels. Donc, notre premier rÃ©flexe n'est pas toujours de regarder ailleurs comment les autres font.
Enfin, Ã§a, c'Ã©tait mon cas.

De retour Ã  l'histoire! Je commenÃ§ais Ã  regarder en ligne Ã  des guides, des pratiques, des _patterns_, etc. Je suis tombÃ© sur plein de sujets excitants. C'Ã©tait comme si j'avais ouvert une fenÃªtre sur un tout nouveau monde. Le _testing_ Ã©tait un de ces sujets.
Et ce n'Ã©tait pas une adoption immÃ©diate de ma part! Bien que je comprenais pourquoi c'Ã©tait fait et tous les bÃ©nÃ©fices en consÃ©quence, je pensais que c'Ã©tait trop dur parce que je ne voyais pas comment introduire des tests dans mon projet du moment. La vÃ©ritÃ©? OUI, c'Ã©tait dur.
Mais pas parce que c'Ã©tait du _testing_: le produit sur lequel je travaillais Ã©tait en fait un monolithe extrÃ¨mement couplÃ©.

Je savais que je devais apprendre des principes et des _patterns_ (principalement sur comment construire une application maintenable) avant d'Ãªtre capable d'introduire des tests. Ã‡a m'a pris du temps avant que je ne sois vraiment apte Ã  travailler avec une approche conduite par les tests.

<AnchoredP id='what-is-it'>
	ğŸ”¸ Ok! Par contre, histoire de ne pas perdre les lecteurs... tu sais expliquer
	ce qu'est test unitaire s'il te plaÃ®t?
</AnchoredP>

ğŸ”¹ Oui, bien sÃ»r! Un test unitaire, c'est un test qui vÃ©rifie un _unit of code_. Et c'est lÃ  que les interprÃ©tations divergent.
Certaines personnes vont voir Ã§a comme un bout de code (ce qui est mon cas). Une mÃ©thode, c'est un _unit of code_ et donc quelque chose que l'on peut tester.
Puis d'autres personnes peuvent voir Ã§a comme un _behavior_. Ce qui n'est pas faux non plus mais Ã§a dÃ©pend de comment tu vois la chose.

Mais Ã  la fin, un test unitaire, c'est simplement **un morceau de code qui valide qu'un autre morceau de code a le rÃ©sultat attendu par rapport Ã  un scÃ©nario donnÃ©**.

<AnchoredP id='hierarchy-position'>
	ğŸ”¸ D'accord, mais du coup, Ã§a se situe oÃ¹ dans la "hiÃ©rachie des tests"? Ne me
	dis pas Â« tout Ã  gauche Â» sinon je vais Ãªtre fÃ¢chÃ©!
</AnchoredP>

ğŸ”¹ Sur ton graphe, Ã§a se situe tout Ã  fait Ã  gauche <img style={{ display: "inline" }} src="https://www.pinclipart.com/picdir/big/524-5246191_troll-face-meme-png-troll-face-clipart.png" width="16" height="16" />
mais la rÃ©ponse que tu attends, j'imagine que c'est pourquoi. Je ne suis pas entiÃ¨rement sÃ»r... mais je dirais que l'ordre de gauche Ã  droite n'est pas annodin.
Ã€ mon sens, plus tu avances vers la droite, plus la portÃ©e fonctionnelle de ton test est grande.

Nous, on se situe sur la partie "unit" puisque techniquement, il n'y a pas plus petit qu'une _unit_. On va absolument pas tester ce qu'il y a autour. Le test unitaire doit Ãªtre exÃ©cutÃ© de faÃ§on _standalone_ et tu dois te trouver dans un environnement _sandbox_.
C'est-Ã -dire que ton test unitaire n'a aucun impact sur l'extÃ©rieur du test, et si tu en lances plusieurs en parallÃ¨le, ils ne doivent pas se court-circuiter les uns les autres.

Ã‡a signifie donc que, dans un test unitaire: on ne contacte pas de DB, on Ã©vite de faire une requÃªte web, d'accÃ©der Ã  un fichier du systÃ¨me, etc. De la mÃªme faÃ§on, on ne va pas contacter les autres dÃ©pendances de la solution.
On reste vraiment "interne" Ã  la fonction.

<Figure
	data={{
		src: '/img/software-testing-types.png',
		alt: 'Types de Software Testing',
		type: 'image',
	}}
/>

Si je regarde l'image et que je parle de chaque point de la partie _functional testing_:

- l'_unit testing_, c'est vÃ©rifier qu'un composant fonctionne bien ;
- l'_integration testing_, c'est vÃ©rifier que certains composants fonctionnent bien entre eux ;
- et Ã§a continue ainsi en augmentant la portÃ©e des tests jusqu'Ã  l'_user acceptance testing_ qui consiste Ã  vÃ©rifier l'entiÃ¨retÃ© de l'application tout en Ã©vitant de contacter les dÃ©pendances externes (ex: des requÃªtes vers des fournisseurs de donnÃ©es extÃ©rieurs Ã  ton application).
  Ce qui signifie qu'on est sur la portÃ©e globale de l'application, et donc que potentiellement, on va aller tester jusqu'Ã  la base de donnÃ©es.

<AnchoredP>
	ğŸ”¸ D'accord! Mais pourquoi le testing, c'est pas rÃ©alisÃ© dans le monde
	professionnel? Aussi bien les tests unitaires que les tests d'intÃ©gration...
</AnchoredP>

ğŸ”¹ En rÃ©alitÃ©, peu de gens font des tests. Et comme peu de gens font dÃ©jÃ  des tests unitaires, encore une petite partie de ces gens-lÃ  font des tests d'intÃ©gration.
Pour la simple et bonne raison, que pour pouvoir faire de bons tests d'intÃ©gration, il faut dÃ©jÃ  faire de bons tests unitaires avant. Alors, ce n'est pas "obligatoire", tu peux faire des tests d'intÃ©gration sans forcÃ©ment avoir des tests unitaires.
Mais Ã§a n'a pas la mÃªme portÃ©e, ce n'est pas exÃ©cutÃ© en mÃªme temps, ... Maintenant, le problÃ¨me, c'est que si tu ne fais pas de tests unitaires et que tu ne fais que des tests d'intÃ©gration et qu'un test d'intÃ©gration Ã©choue... Bah tu ne sauras pas si
Ã§a provient d'un problÃ¨me au niveau d'une mÃ©thode ou au niveau de l'intÃ©gration entre 2 composants.

Du coup, les tests d'intÃ©gration sont importants. Mais je considÃ¨re, Ã  tort ou Ã  raison, que les tests unitaires sont un prÃ©-requis pour faire des tests d'intÃ©gration efficaces.

<Figure
	data={{
		src: randomChoose(
			'https://miro.medium.com/max/600/1*xHibbXdcePT0GtpeZRgxSA.gif',
			'https://media4.giphy.com/media/hqq505vU9iHCOGySD5/giphy.gif',
			'https://media1.giphy.com/media/VXmWbcDSj2yqnsXUrF/giphy.gif'
		),
		alt: 'GIF on integration testing',
		type: 'image',
	}}
/>

<AnchoredP>
	ğŸ”¸ Et pourtant, tu peux Ã©galement trouver des projets qui possÃ¨dent des tests
	unitaires mais pas obligatoirement des tests d'intÃ©gration.
</AnchoredP>

ğŸ”¹ C'est une question de besoin. Dans une approche TDD (ndlr: on en parle plus bas!), tu sais que ton application va Ãªtre robuste. Parce que si jamais tous tes composants sont robustes, il y a de grandes chances pour que ton application le soit aussi.
Ã‡a ne veut pas dire que tu n'auras pas de problÃ¨me lorsqu'ils vont travailler les uns avec les autres, mais en ayant du testing de faÃ§on globale sur ton application, tu rÃ©duis la quantitÃ© d'erreurs qu'il te reste et donc, tu peux facilement trouver le problÃ¨me.

Et donc, aprÃ¨s, c'est une question de "quel est le coÃ»t de le faire, quel est le coÃ»t de ne pas le faire". Et des fois, Ã§a vaut pas le coup. Potentiellement, on sait que l'on va avoir quelques bugs et qu'on arrivera Ã  les gÃ©rer, mais la majoritÃ© des bugs seront
gÃ©rÃ©s en amont grÃ¢ce Ã  des tests unitaires.

<AnchoredP id='objective'>
	ğŸ”¸ C'est quoi le but du testing unitaire et quand est-ce que Ã§a devrait Ãªtre
	appliquÃ©?
</AnchoredP>

ğŸ”¹ Le but est assez simple: c'est de montrer qu'une mÃ©thode fonctionne comme tu l'attends. C'est-Ã -dire que tu vas avoir un requirement, par exemple ta mÃ©thode `doSomething` doit te retourner quelque chose, et tu dois vÃ©rifier que sur diffÃ©rents scÃ©narios que tu lui donnes,
elle se comporte toujours de la bonne faÃ§on.

Pour ce qui est du "quand", et bien c'est simple: Ã§a doit Ãªtre appliquÃ© Ã  partir du moment oÃ¹ tu as de la logique quelque part.

<AnchoredP id='pros-and-cons'>
	ğŸ”¸ Bah du coup, quels en sont les avantages et inconvÃ©nients de la mise en
	place de tests unitaires?
</AnchoredP>

ğŸ”¹ Comme dit prÃ©cÃ©demment, tu Ã©cris du code pour vÃ©rifier du code. Oui, mais il existe d'autres intÃ©rÃªts derriÃ¨re!

1. Une suite de tests devient ce qu'on appelle une **documentation vivante**.

   Notamment lorsque quelqu'un arrive sur ton projet. Il voit une mÃ©thode qui peut Ãªtre complexe (ou pas, peu importe). Il n'est pas forcÃ©ment sensÃ© connaÃ®tre ou deviner tous les tenants et aboutissants de la mÃ©thode. Par contre, il y a une faÃ§on trÃ¨s simple pour lui de savoir quels sont les rÃ©sultats attendus et comment la mÃ©thode devrait fonctionner:
   c'est de regarder le nom des 4-5 tests qui passent sur ta mÃ©thode. Ã‡a facilite donc l'_onboarding_!

   De plus, lÃ  oÃ¹ un commentaire ne reste jamais Ã  jour avec le reste du code, le test unitaire sera toujours up to date. Si ce n'est pas le cas, alors ta compilation ne passe pas.

2. Le test unitaire sert aussi de **filet de sÃ©curitÃ© contre la rÃ©gression**.

   Au bout d'un moment dans un projet, tu fais du _refactoring_. Et quand tu modifies du code, tu casses toujours un truc. C'est dÃ©jÃ  arrivÃ©, Ã§a arrivera encore.
   Mais ton test unitaire, il est lÃ . Au moment du _build_, si tu as cassÃ© quelque chose pendant ta refonte de code, ton test unitaire te le marque en rouge! Et Ã§a, pour un dÃ©veloppeur, c'est Ã©norme! Tu es beaucoup plus serein, et tu passes bien moins de temps Ã  vÃ©rifier que tes changements n'ont pas eu d'impacts sur le reste du code.
   Pas besoin de relancer la solution, pas besoin de vÃ©rifier chaque page de ton site, chaque bouton de ton application mobile, etc. Si tu es couvert par des tests unitaires, tu n'as pas peur du _refactoring_.

3. Ã‰crire des tests, Ã§a amÃ©liore forcÃ©ment la **stabilitÃ© du code** de ton application, ce qui produit par consÃ©quent **moins de bugs**.

4. Dans la continutÃ© du point prÃ©cÃ©dent, Ã§a **rÃ©duit le temps de dÃ©tection des bugs**. Mais Ã§a, on en parlera plus tard!

5. C'est pas rÃ©ellement un avantage direct, mais je pense que c'est important de le mentionner: **faire du testing unitaire te rend meilleur**.

   Pour faire en sorte que tu puisses Ã©crire des tests unitaires, tu dois respecter certains principes. Tu dois toujours avoir une certaine couche abstraction, pour _mocker_ tes dÃ©pendances, tu dois pouvoir les injecter,... en fait tu vas te forcer Ã  appliquer SOLID le plus souvent possible.
   Et du coup, Ã§a te force Ã  casser des composants, Ã  les dÃ©coupler, Ã  rÃ©flÃ©chir et Ã  prÃ©voir tout Ã§a. Chose que tu n'es pas obligÃ© de faire si tu ne fais pas de tests. Et donc, action-rÃ©action: tu deviens un meilleur dÃ©veloppeur.

6. Faire des tests unitaires prouve que, derriÃ¨re le projet, il y a un **objectif long terme**. En effet, la mise en place de tests, Ã§a demande une analyse rigoureuse des demandes du client ainsi que des _requirements_.
   Et tout Ã§a montre que le client est impliquÃ© dans le dÃ©veloppement du projet car il y a potentiellement un rÃ©el besoin.

ğŸ”¸ Et comme c'est peu mis en place dans les entreprises, c'est vu comme "nouveau" et Ã§a motive Ã  en apprendre plus!

ğŸ”¹ Ouais mais Ã§a, chacun peut le voir diffÃ©rement. Certains (comme toi) le voient comme quelque chose d'intÃ©ressant.
Dans un contexte un poil diffÃ©rent, d'autres pourraient le prendre comme une pression supplÃ©mentaire alors qu'ils sont dÃ©jÃ  sous l'eau.

Pour ce qui est des inconvÃ©nients, je dirais que:

1. il y a des prÃ©-requis: il faut des notions sur les principes de l'orientÃ© objet (et notamment l'abstraction), sur l'injection de dÃ©pendances, sur les principes [SOLID](https://www.digitalocean.com/community/conceptual_articles/s-o-l-i-d-the-first-five-principles-of-object-oriented-design)...
2. c'est flagrant mais il y a peu de personnes compÃ©tentes pour te coacher correctement sur le sujet.
3. il y a une courbe d'apprentissage/de progression assez importante. Si quelqu'un met 4 heures pour dÃ©velopper une fonctionnalitÃ©, cette mÃªme personne mettra probablement aussi 4 heures pour Ã©crire les tests.
4. Ã§a demande de la prÃ©paration : il faut rÃ©flÃ©chir Ã  l'architecture du projet, aux relations entre les diffÃ©rents composants, ...
5. il y a un manque de comprÃ©hension du cÃ´tÃ© des autres dÃ©partements (non-IT) sur le sujet.

On entend souvent dire que "Ã§a prend du temps et que Ã§a sera planifiÃ© plus tard" ou que "les dÃ©veloppeurs n'ont pas le temps" mais ces inconvÃ©nients n'en sont pas vraiment.
En effet, le premier indique clairement un manque de vision long terme sur le produit alors que le second indique un problÃ¨me d'organisation (les tests devraient Ãªtre inclus dans l'estimation de dÃ©veloppement d'une fonctionnalitÃ©).

<AnchoredH2 id='details'>En dÃ©tails</AnchoredH2>

<AnchoredP id='bugs-still-occur'>
	ğŸ”¸ Parfois, tu as quand mÃªme des problÃ¨mes qui surviennent dans des
	applications couvertes par des tests unitaires. Pourquoi?
</AnchoredP>

ğŸ”¹ Ã‰videmment, le risque zÃ©ro n'existe pas. Ta suite de tests peut avoir un scÃ©nario non-couvert.
Elle peut potentiellement laisser passer des choses parce que tu as soit oublier un test unitaire (un scÃ©nario que tu as oubliÃ© de prÃ©voir) soit une intÃ©gration qui se passe mal entre des composants.
C'est pas la mort hein!

Admettons: tu prends le cas d'un _refactoring_ qui te gÃ©nÃ¨re 10 bugs. Le mÃªme _refactoring_ couvert de tests unitaires te gÃ©nÃ¨re 1 bug. Il reste 1 bug, c'est pas terrible. Mais, Ã§a ira plus vite de rÃ©gler 1 bug que 10.

<AnchoredP id='test-coverage'>
	ğŸ”¸ Et le <span style={{ fontStyle: 'italic' }}>test coverage</span>, dans tout
	Ã§a?
</AnchoredP>

Donc d'accord, le test unitaire n'a pas rÃ©ponse Ã  tout. Et c'est lÃ  qu'on arrive sur le _coverage_. C'est une mÃ©trique informative sur la progression de couverture de tests de ton application.
Cependant, c'est mal de mesurer la qualitÃ© de la suite de tests sur base de sa couverture. Tu peux avoir un _coverage_ Ã  100% avec absolument rien qui est testÃ©. Il suffit de faire uniquement des tests qui ne vÃ©rifient rien, ou qui font des vÃ©rifications bidons (0 est Ã©gal Ã  0 â†’ toujours vrai).
Tu as un coverage complet, mais la stabilitÃ© de ton application n'est absolument pas vÃ©rifiÃ©e.

Le seul moyen de vÃ©rifier la qualitÃ© d'une suite unitaire d'un projet, c'est de se poser quelques questions:

- est-ce que le temps de dÃ©veloppement gÃ©nÃ©ral des fonctionnalitÃ©s diminue?
- est-ce que la quantitÃ© de bugs trouvÃ©s en production diminue?
- est-ce que tu arrives Ã  facilement accueillir une nouvelle ressource au sein de l'Ã©quipe de dÃ©veloppement?
- est-ce que les dÃ©veloppeurs ont confiance en leur code quand ils terminent une fonctionnalitÃ©?

Le soucis, c'est que c'est dur de faire de la mÃ©trique sur tous ces points...

<AnchoredP id='black-and-white-boxes'>
	ğŸ”¸ Ok! Et si on parlait maintenant de black-box et white-box testing?
</AnchoredP>

ğŸ”¹ C'est le moment pour moi de montrer mes talents insoupÃ§onnÃ©s de dessinateur!

<Figure
	data={{
		src: '/img/black-white-box-testing.png',
		alt: 'Black and white box testing',
		type: 'image',
		style: { border: '.5em solid black' },
	}}
/>

Le **black box testing**, c'est donner une information d'entrÃ©e Ã  l'_unit of code_, et vÃ©rifier l'information de sortie. C'est aussi simple que Ã§a: on ne prend pas en compte ce qu'il se passe Ã  l'intÃ©rieur de la mÃ©thode.
C'est pas mal, c'est un dÃ©but, mais je trouve que c'est dommage de s'arrÃªter lÃ . C'est typiquement le genre de tests ajoutÃ©s en cours de route sur une application _legacy_ oÃ¹ c'est compliquÃ© de vÃ©rifier tout ce qu'il se passe parce qu'il y a dÃ©jÃ  beaucoup.

Prenons par exemple une classe `Calculator`:

```csharp title='src/Calculator.cs'
public class Calculator
{
	public int Sum(int x, int y)
	{
		return x + y;
	}
}
```

Cette classe n'a pas de dÃ©pendance. Et bien, un test sur une mÃ©thode pure (sans dÃ©pendance ou qui n'accÃ¨de qu'Ã  des variables partagÃ©es) est obligatoirement un _black box test_:

```csharp title='tests/CalculatorTests.cs'
[TestClass]
public class CalculatorTests
{
	[TestMethod]
	public int Sum_Should_ReturnTheSumOfTheTwoNumbers()
	{
		Calculator calculator = new();

		int result = calculator.Sum(2,3);

		Assert.AreEqual(expected: 5, actual: result);
	}
}
```

Par contre, de l'autre cÃ´tÃ©, on a le **white box testing**. C'est concrÃ¨tement la mÃªme chose: on donne un _input_ et on vÃ©rifie l'_output_ (c'est le but d'un test unitaire, finalement). Mais on va aussi vÃ©rifier ce qu'il se passe Ã  l'intÃ©rieur de l'_unit of code_.
Et donc potentiellement vÃ©rifier que ta mÃ©thode a bien fait appel Ã  sa dÃ©pendance, que la valeur a bien Ã©tÃ© mise dans un cache, sauvegardÃ©e dans un repo, qu'un event a bien Ã©tÃ© Ã©mis, etc. et lÃ , tout de suite, Ã§a donne plus de valeurs Ã  ton test.
Parce qu'on va dÃ©finir le _behavior_ de ton test de faÃ§on plus prÃ©cise, plus complÃ¨te, en vÃ©rifiant ce qu'il se passe Ã  l'intÃ©rieur.

<AnchoredP id='why-not-popular'>
	ğŸ”¸ Ah d'accord! Mais du coup, pourquoi ce n'est pas plus adoptÃ© par les
	dÃ©veloppeurs?
</AnchoredP>

ğŸ”¹ C'est vraiment une interprÃ©tation personnelle parce que je ne dÃ©tiens pas la sainte vÃ©ritÃ©.
Je pense que dans notre cas, malgrÃ© le fait que l'on fait du dÃ©veloppement de logiciels depuis plusieurs dÃ©cennies, on n'est pas encore sur un dÃ©veloppement logiciel "mature": si tu regardes en dÃ©tails, tu verras exactement les mÃªmes problÃ¨mes dans tous les projets sur lesquels on peut travailler.
Rajoute Ã  Ã§a le fait que le testing unitaire n'est pas forcÃ©ment (bien) enseignÃ© quand on est Ã  l'Ã©cole, et de ce fait pas appliquÃ© en entreprise.

Par consÃ©quent, tu n'as pas d'apprentissage continu sur le sujet, et donc tu tombes dans un cercle vicieux : personne n'en fait donc personne n'en fait.
Puis, combien de fois n'as-tu pas entendu "on fera les tests Ã  la fin" quand tu proposes d'en faire? Alors que faire Ã§a, c'est perdre pratiquement tous les avantages!

<AnchoredP>
	ğŸ”¸ Personnellement, j'ai eu la chance de faire mes Ã©tudes dans une institution
	qui tenait Ã  coeur d'enseigner en Ã©tant alignÃ©e avec le monde professionel
	mais aussi vis-Ã -vis des nouvelles technologies. Et pourtant, nous n'avons eu
	qu'une introduction aux tests unitaires. En tant qu'Ã©tudiant, Ã§a te tombe
	dessus et tu n'as pas forcÃ©ment le bagage nÃ©cessaire pour comprendre tout ce
	que l'on te demande. Pour ma part, Ã  l'Ã©poque, je n'avais absolument pas
	compris l'utilitÃ© du testing unitaire, et j'avais bÃ¢clÃ© la question Ã 
	l'examen!
</AnchoredP>

ğŸ”¹ La nivellation par le bas est perpÃ©tuelle. C'est d'autant plus embÃªtant pour les gens qui sont de bonne volontÃ© et qui veulent mettre des tests unitaires en place.
Dans l'industrie (sauf sur les projets qui sont chapeautÃ©s par des boÃ®tes qui ont plutÃ´t bonne conscience), tu vas Ãªtre fortement incitÃ© Ã  faire du _quick and dirty_.
Le problÃ¨me, c'est que tu es sur des solutions qui n'ont dÃ©jÃ  pas de tests unitaires. Comme je le disais avant, quand tu n'as pas de tests et que ton systÃ¨me grandit Ã  tous les niveaux:

- tes dÃ©veloppements te prennent beaucoup plus de temps ;
- t'as de plus en plus de bugs Ã  rÃ©gler ;
- comme Ã§a te gÃ©nÃ¨re plus de bugs, t'as plus de travail et donc t'as moins de temps pour Ã©crire des tests sur ta solution existante...

  ...en sachant qu'il y a une courbe de progression. Tu ne peux pas dire Ã  ton Ã©quipe du jour au lendemain : "allez hop, aujourd'hui tout le monde Ã©crit des tests unitaires" et t'as 100% de coverage. Ã‡a, Ã§a n'existe pas.

Tu es dÃ©jÃ  sur un flux tendu parce que tu n'as pas fait tes tests en amont, ce qui fait que tu te tapes toutes les consÃ©quences dans la figure.
Et donc, inciter une adoption aux tests unitaires et Ã  TDD devient d'autant plus compliquÃ© parce que les gens sont dÃ©jÃ  totalement noyÃ©s.

<AnchoredP id='cost'>
	ğŸ”¸ Bon sinon... question coÃ»t, qu'est-ce qu'il en est? Parce que finalement,
	Ã©crire un test unitaire, c'est tout de mÃªme Ã©crire du code. Ã‡a coÃ»te!
</AnchoredP>

ğŸ”¹ Oui et non. Ã‡a va dÃ©pendre de ton contexte, mais je ne pense pas que l'on devrait les compter dans le budget. Ou du moins, on ne devrait pas les voir comme une charge supplÃ©mentaire parce qu'ils te font gagner Ã©normÃ©ment de temps sur le long terme.
Donc ta stratÃ©gie de projet va dÃ©pendre de comment tu vois ces tests unitaires, mais de mon point de vue, c'est un **Ã©norme** gain de temps!

C'est sÃ»r que dÃ©velopper une fonctionnalitÃ© va te prendre un peu plus de temps (et encore! Ã§a va dÃ©pendre des personnes et de leur degrÃ© d'affinitÃ© avec Ã§a), mais d'un autre cÃ´tÃ©, Ã§a va te "sauver la vie" pas mal de fois parce que tu vas Ã©viter Ã©normement de bugs qui, en temps normal,
seraient arrivÃ©s bien plus tard dans ton _process_ (que Ã§a soit lors des tests utilisateur sur un environnement de QA ou en production). Et **plus un bug est dÃ©couvert tard, plus il coÃ»te cher**:

<Figure
	data={{
		src: 'https://assets.deepsource.io/995f56d/images/blog/cost-of-fixing-bugs/chart.jpg',
		alt: 'CoÃ»t de correction des bugs',
		type: 'image',
		url: 'https://deepsource.io/blog/exponential-cost-of-fixing-bugs/',
	}}
>
	Le coÃ»t de correction d'un bug sur base du moment oÃ¹ il a Ã©tÃ© dÃ©tectÃ©, sourcÃ©
	chez{' '}
	<a href='https://deepsource.io/blog/exponential-cost-of-fixing-bugs/'>
		DeepSource
	</a>
	!
</Figure>

C'est normal: un bug dÃ©couvert par un test unitaire, il est dÃ©couvert directement sur ta machine, en local. Tu le corriges toi-mÃªme et c'est terminÃ©.

A contrario, un bug qui passe en production... il est dÃ©couvert par un utilisateur qui doit ouvrir un ticket. Ce ticket, il va Ãªtre gÃ©rer par ton _Product Owner_. Il va Ãªtre inclus
dans un _sprint_, puis il sera assignÃ© Ã  un dÃ©veloppeur. Ensuite, il va y avoir une phase d'investigation (reproduction du bug), une phase de correction de bug et aprÃ¨s
Ã§a doit repartir sur tous les environnements et Ãªtre validÃ© par des _Quality Assurance Users_.

Alors qu'un test en quelques lignes de code aurait empÃªchÃ© tout Ã§a.

_ndlr: pour en savoir plus sur les raisons qui font qu'un logiciel a des bugs, n'hÃ©sitez pas Ã  consulter [cette page](https://www.softwaretestinghelp.com/why-does-software-have-bugs)!_

<AnchoredP id='how-to-write'>
	ğŸ”¸ La question que tous se posent... Comment Ã©crire de bons tests unitaires?
</AnchoredP>

ğŸ”¹ Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet

<AnchoredH2 id='more-stuff'>Pour aller plus loin</AnchoredH2>

<AnchoredP id='libraries'>
	ğŸ”¸ Tu as des librairies intÃ©ressantes en tÃªte pour faciliter le travail?
</AnchoredP>

ğŸ”¹ Oui. Pour moi, il faut considÃ©rer deux groupes de librairies:

1. les librairies de testing, qui permettent de gÃ©nÃ©rer des tests unitaires. Mais je pense que ce sont vraiment des choix personnels.
2. les librairies de mocking, qui permettent de surcharger le comportement de tes dÃ©pendances et notamment de les monitorer. Mais c'est pareil, c'est trÃ¨s subjectif.

Pour ma part:

|                     **Frameworks de test**                     |                 **Librairies de mocking**                  |
| :------------------------------------------------------------: | :--------------------------------------------------------: |
| [MSTest](https://www.nuget.org/packages/MSTest.TestFramework/) |         [Moq](https://www.nuget.org/packages/Moq/)         |
|         [NUnit](https://www.nuget.org/packages/NUnit/)         |     [NInject](https://www.nuget.org/packages/Ninject/)     |
|         [XUnit](https://www.nuget.org/packages/xunit/)         | [AutoFixture](https://www.nuget.org/packages/AutoFixture/) |
|                                                                |  [WireMock](https://www.nuget.org/packages/WireMock.Net/)  |

ğŸ”¸ Sur ce point-ci particuliÃ¨rement, j'aimerais mettre en avant le fait qu'il existe aussi des librairies de test pour le _front-end_. En fait, le testing unitaire n'est pas rÃ©servÃ© aux dÃ©veloppeurs
_back-end_. On citera notamment [Jest](https://www.npmjs.com/package/jest), [Mocha](https://www.npmjs.com/package/mocha), [Cypress](https://www.npmjs.com/package/cypress) et [Jasmine](https://www.npmjs.com/package/jasmine) comme librairies fortement liÃ©es au testing dans des applications JavaScript.

<AnchoredP id='what-is-tdd'>
	Oh d'ailleurs, on entend beaucoup parler du{' '}
	<span style={{ fontStyle: 'italic' }}>Test Driven Development</span> (TDD).
	C'est quoi?
</AnchoredP>

ğŸ”¹ Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet

<AnchoredP id='what-is-tcr'>
	ğŸ”¸ J'ai ouÃ¯e dire que t'as rÃ©cemment appris le{' '}
	<span style={{ fontStyle: 'italic' }}>Test && Commit || Revert</span> (TCC).
	Tu sais expliquer en quoi Ã§a consiste?
</AnchoredP>

ğŸ”¹ Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet

<AnchoredP id='tips-to-start'>
	ğŸ”¸ T'as des tips pour se lancer dans le testing unitaire?
</AnchoredP>

ğŸ”¹ Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet

<AnchoredP id='how-to-convince-to-use'>
	ğŸ”¸ Comment convaincre quelqu'un d'Ã©crire des tests unitaires?
</AnchoredP>

ğŸ”¹ Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet

<AnchoredP id='bad-smells'>
	ğŸ”¸ Quels sont les "bad smells" dans l'unit testing?
</AnchoredP>

ğŸ”¹ Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet

<AnchoredH2 id='conclusion'>Conclusion</AnchoredH2>

<AnchoredP>ğŸ”¸ Un dernier mot pour clÃ´turer cette interview?</AnchoredP>

ğŸ”¹ Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit ame
Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet

<Newsletter url={MAILCHIMP_URL} />

export const toc = [
	{
		value: 'PrÃ©sentation',
		id: 'presentation',
		children: [],
		level: 2,
	},
	{
		value: 'Le sujet',
		id: 'topic',
		children: [
			{
				value: 'PremiÃ¨re rencontre',
				id: 'first-encounter',
				children: [],
				level: 3,
			},
			{
				value: "Qu'est-ce que c'est",
				id: 'what-is-it',
				children: [],
				level: 3,
			},
			{
				value: 'OÃ¹ Ã§a se situe dans la "hiÃ©rarchie des tests"',
				id: 'hierarchy-position',
				children: [],
				level: 3,
			},
			{
				value: 'But du testing unitaire',
				id: 'objective',
				children: [],
				level: 3,
			},
			{
				value: 'Avantages et inconvÃ©nients',
				id: 'pros-and-cons',
				children: [],
				level: 3,
			},
		],
		level: 2,
	},
	{
		value: 'Plus en dÃ©tails',
		id: 'details',
		children: [
			{
				value: 'Y toujours des bugs',
				id: 'bugs-still-occur',
				children: [],
				level: 3,
			},
			{
				value: 'Test Coverage',
				id: 'test-coverage',
				children: [],
				level: 3,
			},
			{
				value: 'Black-box & white-box, kÃ©sako',
				id: 'black-and-white-boxes',
				children: [],
				level: 3,
			},
			{
				value: 'ProblÃ¨me de popularitÃ©',
				id: 'why-not-popular',
				children: [],
				level: 3,
			},
			{
				value: 'Le coÃ»t',
				id: 'cost',
				children: [],
				level: 3,
			},
			{
				value: 'Comment en Ã©crire efficacement',
				id: 'how-to-write',
				children: [],
				level: 3,
			},
		],
		level: 2,
	},
	{
		value: 'Pour aller plus loin',
		id: 'more-stuff',
		children: [
			{
				value: "Librairies facilitant l'implÃ©mentation",
				id: 'libraries',
				children: [],
				level: 3,
			},
			{
				value: 'Le Test Driven Development',
				id: 'what-is-tdd',
				children: [],
				level: 3,
			},
			{
				value: 'Le Test && Commit || Revert ',
				id: 'what-is-tcr',
				children: [],
				level: 3,
			},
			{
				value: 'Tips pour se lancer',
				id: 'tips-to-start',
				children: [],
				level: 3,
			},
			{
				value: "Comment convaincre d'en Ã©crire",
				id: 'how-to-convince-to-use',
				children: [],
				level: 3,
			},
			{
				value: 'Les "Bad Smells"',
				id: 'bad-smells',
				children: [],
				level: 3,
			},
		],
		level: 2,
	},
	{
		value: 'Conclusion',
		id: 'conclusion',
		children: [],
		level: 2,
	},
];
