---
slug: unit-testing
title: Les tests unitaires
tags: [test, test unitaire, programmation]
description: L'article du jour est fait en effort conjoint avec mon ancien collÃ¨gue et mentor <a href="https://www.linkedin.com/in/guillaumefaas/" target="_blank" rel="noreferrer noopener nofollow">Guillaume Faas</a> sous la forme d'une conversation entre 2 dÃ©veloppeurs. Joins-toi Ã  moi pour le remercier pour son incroyable implication dans l'Ã©criture de cet article! Nous espÃ©rons tous les 2 que tu vas l'adorer, autant que nous avons adorÃ© l'Ã©crire!
image: img/unit-testing.jpg
---

import Figure from '../../../src/components/figure';
import SEO from '../../../src/components/seo';
import Reminder from '../../../src/components/reminder';
import Newsletter from '../../../src/components/newsletter';
import { MAILCHIMP_URL } from '../../../website_config.json';
import { AnchoredH2, AnchoredP } from '../../../src/components/AnchoredHeading';
import randomChoose from '../../../src/utils/randomChoose';

<a href='/blog/unit-testing'>
	<Figure
		data={{
			src: '/img/unit-testing.jpg',
			alt: 'Tests unitaires',
			type: 'image',
		}}
	/>
</a>

L'article du jour est fait en effort conjoint avec mon ancien collÃ¨gue et mentor <a href="https://www.linkedin.com/in/guillaumefaas/" target="_blank" rel="noreferrer noopener nofollow">Guillaume Faas</a>
(ğŸ”¹) sous la forme d'une interview d'un dÃ©veloppeur.

Joins-toi Ã  moi pour le remercier pour son incroyable implication dans l'Ã©criture de cet article! Nous espÃ©rons tous les deux que tu vas l'adorer, autant que nous avons adorÃ© l'Ã©crire.

<!--truncate-->

<SEO uri='blog/unit-testing' image='img/unit-testing.jpg' type='article' />

---

<Reminder />

---

_tldr; fais des katas en appliquant la mÃ©thodologie "Test Driven Development" !_

<AnchoredH2 id='presentation'>PrÃ©sentation</AnchoredH2>

<AnchoredP>ğŸ”¸ Salut Guillaume! Tu sais te prÃ©senter s'il te plaÃ®t?</AnchoredP>

ğŸ”¹ Salut TinaÃ«l! Merci de m'avoir invitÃ© Ã  parler sur ton site. Je m'appelle Guillaume Faas et je suis un expert .NET / Software Craftsman, actuellement employÃ© chez [Squaremiled S.A.](https://squaremiled.com/).
Je dÃ©veloppe des logiciels depuis une dizaine d'annÃ©es en ayant Ã©voluÃ© dans des environnements et secteurs d'activitÃ©s variÃ©s.

<AnchoredH2 id='topic'>Le sujet!</AnchoredH2>

<AnchoredP>ğŸ”¸ De quoi va-t-on parler aujourd'hui?</AnchoredP>

ğŸ”¹ Ã€ ton avis? Tu n'as pas lu le titre de l'article on dirait. On va parler de **test unitaire**!

<AnchoredP id='first-encounter'>
	ğŸ”¸ Quand est-ce que t'y as touchÃ© pour la premiÃ¨re fois?
</AnchoredP>

ğŸ”¹ C'Ã©tait il y a bien longtemps, dans une galaxie lointaine... J'avais Ã  peine quelques annÃ©es d'expÃ©rience Ã  l'Ã©poque. J'Ã©tais dans la mÃªme sociÃ©tÃ© pendant une majeure partie de ma carriÃ¨re et, par rapport Ã  mon _day-to-day_, je pensais que j'avais dÃ©jÃ  tout vu.
Je commenÃ§ais Ã  regarder en ligne Ã  des _guidelines_, des _best practices_, des _patterns_, etc. Je suis tombÃ© sur plein de sujets excitants et surtout nouveaux.
C'Ã©tait comme si j'avais mis les pieds dans un nouveau monde qui n'avait rien Ã  voir avec la routine dans laquelle j'Ã©tais ancrÃ©. Le _testing_ Ã©tait Ã©videmment l'un de ces sujets.
Cependant, j'ai vite rÃ©alisÃ© que je devais progresser sur d'autres sujets avant d'Ãªtre capable d'introduire des tests. Cela m'a pris du temps avant que je ne sois vraiment apte Ã  travailler avec une approche _test-driven_.

<AnchoredP id='what-is-it'>
	ğŸ”¸ Ok! Par contre, histoire de ne pas perdre les lecteurs... tu sais
	expliquer ce qu'est un test unitaire s'il te plaÃ®t?
</AnchoredP>

ğŸ”¹ Oui, bien sÃ»r! Un test unitaire, c'est un test qui vÃ©rifie un _unit of code_. La notion de _unit of code_ varie en fonction des Ã©coles de testing.
L'Ã©cole London (ou Mockist) va voir cela comme le plus petit _chunk of code_, on parlera d'une classe ou d'une mÃ©thode. Par contre, l'Ã©cole Detroit (ou Classicist) va voir cela comme un _behavior_, donc un ensemble de classes ou de mÃ©thodes.
Pour les plus curieux, voici un [article](https://medium.com/@adrianbooth/test-driven-development-wars-detroit-vs-london-classicist-vs-mockist-9956c78ae95f) qui dÃ©taille les diffÃ©rences entre les deux Ã©coles.
Je prÃ©cise qu'une Ã©cole n'est pas meilleure que l'autre, chacune a ses avantages et inconvÃ©nients. C'est une histoire de prÃ©fÃ©rence et de compromis.
La diffÃ©rence principale tient surtout de la taille de ton _System Under Test_ (SUT) et de la relation entre les diffÃ©rents collaborateurs.

Mais Ã  la fin, un test unitaire est simplement **un morceau de code qui valide qu'un autre morceau de code a le rÃ©sultat et/ou _side effect_ attendu par rapport Ã  un scÃ©nario donnÃ©**.

<AnchoredP id='hierarchy-position'>
	ğŸ”¸ D'accord, mais Ã§a se situe oÃ¹ dans la "hiÃ©rachie des tests"?
</AnchoredP>

ğŸ”¹ Il s'agit de la pyramide de testing (_Agile Testing Pyramid_) mais de gauche Ã  droite au lieu de bas en haut. Plus tu seras situÃ© vers la gauche, plus ton _scope_ est petit et plus tes tests seront nombreux et rapides. La logique inverse est appliquÃ©e lorsque tu vas dans l'autre sens.

Nous, on se situe sur la partie "unit" puisque techniquement, il n'y a pas plus petit qu'une _unit_. Un test unitaire doit Ãªtre exÃ©cutÃ© de faÃ§on _standalone_ dans un environnement _sandbox_.
C'est-Ã -dire qu'un test unitaire n'a aucun impact sur l'extÃ©rieur du test, et si tu en lances plusieurs en parallÃ¨le, ils ne doivent pas avoir de _side effects_ entre eux.

Cela signifie donc que dans un test unitaire: on ne contacte pas de DB, on Ã©vite de faire une requÃªte HTTP, d'accÃ©der Ã  un fichier du systÃ¨me, etc. De la mÃªme faÃ§on, on ne va pas contacter les autres dÃ©pendances de la solution.
On reste vraiment "interne" Ã  la fonction.

<Figure
	data={{
		src: '/img/software-testing-types.png',
		alt: 'Types de Software Testing',
		type: 'image',
	}}
/>

Voici quelques points de la partie _functional testing_:

-   l'_unit testing_, c'est vÃ©rifier qu'un composant fonctionne bien. Il s'agit du test le plus rapide, on parlera de _fast feedback loop_ ;
-   l'_integration testing_, c'est vÃ©rifier que plusieurs composants fonctionnent bien entre eux ;
-   le _user acceptance testing_ qui consiste Ã  vÃ©rifier l'entiÃ¨retÃ© de l'application tout en Ã©vitant de contacter les dÃ©pendances externes (ex: des requÃªtes vers des fournisseurs de donnÃ©es extÃ©rieurs Ã  ton application).
    Il s'agit du test le plus reprÃ©sentatif, probablement celui qui a le plus de valeur Ã  l'Ã©chelle du produit car il vÃ©rifie des _business requirements_.

Ã€ noter qu'il n'y a pas d'obligation de tous les implÃ©menter. On pourrait trÃ¨s bien avoir une _test suite_ composÃ©e uniquement de tests d'une seule de ces catÃ©gories. Mais il convient de garder Ã  l'esprit que notre _test suite_ ne sera pas des plus efficaces.

<AnchoredP>
	ğŸ”¸ D'accord! Mais pourquoi le testing, c'est pas rÃ©alisÃ© dans le monde
	professionnel?
</AnchoredP>

ğŸ”¹ En rÃ©alitÃ©, une grande partie des dÃ©veloppeurs n'Ã©crivent pas ou peu de tests. De plus, les tests d'intÃ©grations sont moins rÃ©pandus que les tests unitaires car ils sont plus complexes Ã  Ã©crire. Au final, cette tÃ¢che est souvent vue comme une corvÃ©e ou alors une _extra step_ que l'on fera uniquement si on a le temps.

<Figure
	data={{
		src: randomChoose(
			'https://miro.medium.com/max/600/1*xHibbXdcePT0GtpeZRgxSA.gif',
			'https://media4.giphy.com/media/hqq505vU9iHCOGySD5/giphy.gif',
			'https://media1.giphy.com/media/VXmWbcDSj2yqnsXUrF/giphy.gif'
		),
		alt: "GIF sur les tests d'intÃ©gration",
		type: 'image',
	}}
/>

Uncle Bob en a Ã©galement parlÃ© Ã  une confÃ©rence Ã  Londre en 2018:

<Figure
	data={{
		type: 'html',
		width: '560',
		height: '315',
		src: 'https://www.youtube.com/embed/17vTLSkXTOo?start=552&end=720',
		title: 'YouTube video player of SC London Conference 2018',
		allow: 'accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture',
		allowFullScreen: true,
	}}
/>

<AnchoredP id='objective'>
	ğŸ”¸ C'est quoi le but du testing unitaire et quand est-ce que Ã§a devrait Ãªtre
	appliquÃ©?
</AnchoredP>

ğŸ”¹ Le but est assez simple: c'est de montrer qu'une mÃ©thode fonctionne comme tu l'attends. C'est-Ã -dire que tu vas avoir un comportement attendu, par exemple ta mÃ©thode `getSomething` doit te retourner quelque chose. Tu vas donc tester diffÃ©rents scÃ©narios et vÃ©rifier qu'elle se comporte toujours de la bonne faÃ§on.

Pour ce qui est du "quand", c'est encore plus simple: Ã§a doit Ãªtre appliquÃ© Ã  partir du moment oÃ¹ tu as de la logique quelque part.

<AnchoredP id='pros-and-cons'>
	ğŸ”¸ Bah du coup, quels en sont les avantages et inconvÃ©nients de la mise en
	place de tests unitaires?
</AnchoredP>

ğŸ”¹ Comme dit prÃ©cÃ©demment, tu Ã©cris du code qui teste du code. Vu comme cela, on dirait surtout une charge de travail supplÃ©mentaire sauf qu'il existe de rÃ©els intÃ©rÃªts derriÃ¨re.

1. Le test unitaire sert de **filet de sÃ©curitÃ© contre les rÃ©gressions**.

L'Ã©tape du refactoring intervient systÃ©matiquement dans un projet. Le problÃ¨me Ã©tant qu'Ã  partir du moment oÃ¹ l'on modifie quelque chose, il y a un risque de **rÃ©gression**. On parle de rÃ©gression lorsque quelque chose fonctionnait auparavant et ne fonctionne plus suite Ã  un changement.
C'est prÃ©cisement ici que le test intervient: il permet de garantir que tes composants fonctionnent toujours comme attendu. Si jamais quelque chose ne fonctionne plus suite Ã  un changement, la _test suite_ t'affichera les tests qui ont dÃ©tectÃ© un problÃ¨me avec un beau rond rouge. Et Ã§a, du point de vue d'un dÃ©veloppeur, c'est Ã©norme! Cela veut dire que tu es beaucoup plus serein et que tu passes bien moins de temps Ã  vÃ©rifier que tes changements n'ont pas eu d'effets indÃ©sirables sur le reste des fonctionnalitÃ©s.

2. L'Ã©criture de tests amÃ©liore la **qualitÃ© du code** de ton application.

C'est liÃ© Ã  ce dont on vient d'aborder. Il est probable que les lecteurs aient dÃ©jÃ  rencontrÃ© une situation similaire: lorsque l'on parle de refactoring Ã  un _Product Owner_ ou _Product Manager_, la premiÃ¨re crainte est toujours que quelque chose ne fonctionne plus.
Si tu es couvert par une _test suite_, tu n'as pas peur du refactoring. C'est mÃªme l'inverse, tu es **encouragÃ© Ã  faire du refactoring rÃ©guliÃ¨rement** tout en Ã©tant protÃ©gÃ©.

3. Une suite de tests devient ce qu'on appelle une **living documentation**.

Lorsque l'on parle de documentation, on a tous Ã  l'esprit des commentaires. Le problÃ¨me est qu'ils ne sont jamais Ã  jour avec le reste du code. Le code Ã©volue, la documentation non. Par contre, ton test unitaire sera toujours _up-to-date_. Si ce n'est pas le cas, alors ta suite de tests ne te donnera pas le feu vert pour aller plus loin.

C'est d'autant plus intÃ©ressant dans le cadre d'une arrivÃ©e d'un nouveau dÃ©veloppeur sur le projet. PlutÃ´t que de lire tout le code d'une mÃ©thode pour savoir ce qu'elle fait, il lui suffit de regarder les diffÃ©rents tests de cette mÃ©thode. Chaque comportement sera reprÃ©sentÃ© par un test avec un _naming_ explicite sur le scÃ©nario et rÃ©sultat attendu (ex: `GetItem_ShouldReturnNotFoundResult_GivenItemIsMissing`). **Ã‡a facilite donc l'_onboarding_!**

4. Cela **rÃ©duit le temps de dÃ©tection des bugs**.

On a Ã©voquÃ© le terme _short feedback loop_ un peu plus tÃ´t dans la discussion. Les tests unitaires sont trÃ¨s rapides Ã  exÃ©cuter, ils nous donnent un _feedback_ presque instantanÃ© sur la santÃ© de la solution. Cela veut dire que l'on doit les exÃ©cuter rÃ©guliÃ¨rement. Je schÃ©matise mais on a un bouton (ou un raccourci) qui nous donne un statut Vert/Rouge en quelques secondes. Actionner ce bouton doit devenir quelque chose de systÃ©matique.
Cela a dÃ©jÃ  un intÃ©rÃªt pour nous en tant que dÃ©veloppeurs mais ce n'est pas tout. On en parlera un peu plus tard!

5. Ce n'est pas un avantage direct mais plutÃ´t un effet secondaire: **faire du testing te rend meilleur**.

Pour faire en sorte que tu puisses Ã©crire des tests apportant une rÃ©elle valeur, tu dois respecter certains principes. Tu dois toujours avoir une certaine couche d'abstraction pour _mocker_ tes dÃ©pendances, tu dois pouvoir les injecter, tu dois limiter les responsabilitÃ©s de tes composants, etc... en fait tu vas te forcer Ã  appliquer plusieurs principes rÃ©guliÃ¨rement (SOLID par exemple).
Du coup, cela te force Ã  casser tes composants, Ã  les dÃ©coupler, Ã  penser Ã  leurs interations et responsabilitÃ©s. Bref, Ã  rÃ©flÃ©chir et Ã  te poser beaucoup de questions. Mine de rien, on parle de _code design_! Et donc, action-rÃ©action: tu deviens meilleur au fil du temps. Cela fait trÃ¨s _Happy End_ mais tu vois oÃ¹ je veux en venir.

ğŸ”¸ Et comme c'est peu mis en place dans les entreprises, c'est vu comme "nouveau" et Ã§a motive Ã  en apprendre plus!

ğŸ”¹ Je te rejoins sur l'aspect nouveautÃ© mais il reste surtout prÃ©sent au dÃ©but lorsqu'on dÃ©couvre le sujet. Mais il y a une partie d'interprÃ©tation dans tout cela: certains (comme toi) le voient comme quelque chose d'intÃ©ressant, d'autres le voient comme une corvÃ©e ou une pression supplÃ©mentaire. Tu trouveras toujours des personnes rÃ©fractaires aux tests pour des raisons diverses et variÃ©es. Peut-Ãªtre qu'on aura l'occasion d'aborder les raisons qui sont gÃ©nÃ©ralement Ã©voquÃ©es.

Pour revenir Ã  ta question, voici les inconvÃ©nients qui me viennent Ã  l'esprit:

1. On l'a mentionnÃ©, il y a des prÃ©-requis: il faut comprendre les piliers de l'orientÃ© objet, l'injection de dÃ©pendances, les principes [SOLID](https://www.digitalocean.com/community/conceptual_articles/s-o-l-i-d-the-first-five-principles-of-object-oriented-design), etc.
2. Le fait que l'on trouve peu de projets avec de rÃ©elles _test suites_ rend l'apprentissage moins accessible. Il en va de mÃªme pour trouver un coach passionnÃ© par ce sujet.
3. Il y a une courbe d'apprentissage/de progression assez importante. Tout le monde passe par une phase de frustration au dÃ©but parce que l'on est pas Ã  l'aise et on a l'impression d'Ãªtre plus lent. Il faut rÃ©sister et persÃ©vÃ©rer car les tests nous feront en rÃ©alitÃ© aller plus vite. On en parlera avec l'approche TDD.
4. Cela demande de la prÃ©paration : il faut rÃ©flÃ©chir Ã  l'architecture du projet, aux relations entre les diffÃ©rents composants, etc... Vu comme cela, ce n'est pas vraiment un inconvÃ©nient mais on ne peut pas (plus?) se lancer tÃªte baissÃ©e dans un dÃ©veloppement sans un minimum de rÃ©flexion.
5. Il y a un manque de comprÃ©hension du cÃ´tÃ© des autres Ã©quipes intervenant sur le dÃ©veloppement du produit, notamment non-IT. On retombe toujours sur des discussions sur le _Return On Investement_ (ROI) ou l'impact sur la vÃ©locitÃ©.

On entend souvent dire que "cela prend du temps et que cela sera planifiÃ© plus tard" ou que "les dÃ©veloppeurs n'ont pas le temps" mais ces arguments ne sont pas vraiment valables.
En effet, le premier indique clairement un manque de vision et de comprÃ©hension du testing. DÃ©jÃ  parce que "plus tard" n'arrive jamais. Mais surtout, faire les tests Ã  la fin du dÃ©veloppement n'a aucun sens. On perd tous les avantages qu'apporte le testing. Je l'ai dÃ©jÃ  dit mais on en parlera avec l'approche TDD.
Ensuite, le second indique un problÃ¨me d'organisation. Les tests devraient Ãªtre inclus dans les estimations et pas comme un travail supplÃ©mentaire Ã  rÃ©aliser.

<AnchoredP id='test-coverage'>
	ğŸ”¸ Et le <span style={{ fontStyle: 'italic' }}>test coverage</span>, dans
	tout Ã§a?
</AnchoredP>

ğŸ”¹ Tester, c'est super et on ressent les bÃ©nÃ©fices. Cependant, il faut aussi faire un statut sur l'Ã©tat de la _test suite_. C'est lÃ  qu'on arrive sur le _code coverage_. C'est une mÃ©trique informative sur la progression de couverture de tests de ton application.
J'insiste vraiment sur le cÃ´tÃ© **informatif**. Ce serait une erreur de mesurer la qualitÃ© de la suite de tests sur base de sa couverture. C'est une mÃ©trique de quantitÃ© et non de qualitÃ©.
J'ai dÃ©jÃ  lu des articles sur des sociÃ©tÃ©s qui ont intÃ©grÃ© la valeur de _code coverage_ dans les objectifs des dÃ©veloppeurs et cela a incitÃ© les dÃ©veloppeurs Ã  utiliser de faux tests pour faire gonfler le coverage.

Le seul moyen de vÃ©rifier la qualitÃ© d'une _test suite_ d'un projet, c'est de se poser quelques questions:

-   Est-ce que le temps de dÃ©veloppement gÃ©nÃ©ral des fonctionnalitÃ©s reste approximativement le mÃªme avec le temps?
-   Est-ce que la quantitÃ© de bugs trouvÃ©s en production diminue avec le temps?
-   Est-ce que tu arrives Ã  facilement accueillir une nouvelle ressource au sein de l'Ã©quipe de dÃ©veloppement?
-   Est-ce que les dÃ©veloppeurs ont confiance en leur _test suite_? Est-ce qu'elle est reprÃ©sentative de l'Ã©tat de santÃ© de la solution? Est-ce qu'un rond vert garantit vraiment qu'un composant fonctionne?

Si tu es en mesure de rÃ©pondre "oui" Ã  toutes ces questions, fÃ©licitations! Tu peux Ãªtre fier de la _test suite_ que tu as mis en place.
Le souci? C'est difficile d'avoir une rÃ©ponse Ã  ces questions alors que tu dois rendre des comptes _day one_... Tu remarques d'ailleurs que les trois premiÃ¨res font rÃ©fÃ©rence au **temps**.

<AnchoredP id='cost'>
	ğŸ”¸ Bon sinon... question coÃ»t, qu'est-ce qu'il en est? Parce que finalement,
	Ã©crire un test unitaire, c'est tout de mÃªme Ã©crire du code. Ã‡a coÃ»te!
</AnchoredP>

ğŸ”¹ Je vois lÃ  oÃ¹ tu veux en venir. Non, cela ne coÃ»te pas plus sauf si tu factures au caractÃ¨re!
MÃªme si tu Ã©cris plus de code, tu es vraiment gagnant et pas que sur l'aspect temps. Je t'ai dit qu'on devait parler de TDD? Parce que cela te fait mÃªme gagner du temps Ã  court-terme. Bref.
DÃ©velopper une fonctionnalitÃ© peut te prendre un peu plus de temps en sachant que cela dÃ©pendra surtout de ton aisance avec l'Ã©criture de tests. D'un autre cÃ´tÃ©, cela va surtout te "sauver la vie" pas mal de fois parce que tu vas Ã©viter Ã©normement de bugs qui, en temps normal,
seraient arrivÃ©s bien plus tard dans ton _process_, lors des tests utilisateur sur un environnement de QA ou en production.
Toi qui voulais parler d'argent, **plus un bug est dÃ©couvert tard, plus il coÃ»te cher**:

<Figure
	data={{
		src: 'https://assets.deepsource.io/995f56d/images/blog/cost-of-fixing-bugs/chart.jpg',
		alt: 'CoÃ»t de correction des bugs',
		type: 'image',
		url: 'https://deepsource.io/blog/exponential-cost-of-fixing-bugs/',
	}}>
	Le coÃ»t de correction d'un bug sur base du moment oÃ¹ il a Ã©tÃ© dÃ©tectÃ©,
	sourcÃ© chez{' '}
	<a href='https://deepsource.io/blog/exponential-cost-of-fixing-bugs/'>
		DeepSource
	</a>
	!
</Figure>

Et c'est tout Ã  fait normal.

On peut reparler de la _fast feedback loop_: si un bug est dÃ©couvert par un test unitaire, c'est en local sur ta machine, juste aprÃ¨s le changement (n'oublie pas de _rebuild_ et de _rerun_ ta suite de tests). Il est identifiÃ© rapidement et corrigÃ© rapidement.
Ã€ contrario, un bug qui passe en production... il est dÃ©couvert par un utilisateur qui remonte le problÃ¨me Ã  ta _product team_ qui elle doit analyser le _feedback_ et ouvrir un ticket dans ton _backlog_. Ce ticket, il va Ãªtre priorisÃ© par ton _Product Owner_ pour Ãªtre inclus dans la prochaine itÃ©ration puis il sera assignÃ© Ã  un dÃ©veloppeur. En admettant que ce ne soit pas toi, il y aura une phase d'investigation (reproduction du bug), une phase de correction de bug et aprÃ¨s il doit repartir sur tous les environnements et Ãªtre validÃ© par des _Quality Assurance Users_.

J'ai volontairement pris un cas extrÃªme pour montrer le pire scÃ©nario mais c'est aussi la faÃ§on d'Ãªtre le plus explicite sur le problÃ¨me.
Ce qu'il est important de retenir, c'est qu'un test peut faire gagner beaucoup de temps Ã  beaucoup de personnes, aussi simple soit-il.

_ndlr: pour en savoir plus sur les raisons qui font qu'un logiciel a des bugs, n'hÃ©sitez pas Ã  consulter [cette page](https://www.softwaretestinghelp.com/why-does-software-have-bugs) et [d'autres sur le web](https://www.google.com/search?q=why+do+softwares+have+bugs)!_

<AnchoredH2 id='details'>En dÃ©tails</AnchoredH2>

<AnchoredP id='black-and-white-boxes'>
	ğŸ”¸ Ok! Et si on parlait maintenant de{' '}
	<span style={{ fontStyle: 'italic' }}>black box</span> et{' '}
	<span style={{ fontStyle: 'italic' }}>white box testing</span>?
</AnchoredP>

ğŸ”¹ J'aime les schÃ©mas, tu aimes les schÃ©mas? C'est bien les schÃ©mas!

<Figure
	data={{
		src: '/img/black-white-box-testing.png',
		alt: 'Black and white box testing',
		type: 'image',
		style: { border: '.5em solid black' },
	}}>
	Les diffÃ©rences entre <span style={{ fontStyle: 'italic' }}>black box</span>{' '}
	et <span style={{ fontStyle: 'italic' }}>white box testing</span>
</Figure>

Le **black box testing**, c'est donner une information d'entrÃ©e au SUT et vÃ©rifier l'information de sortie. C'est aussi simple que Ã§a: on ne prend pas en compte ce qu'il se passe Ã  l'intÃ©rieur de la mÃ©thode.
Il y a un cas prÃ©cis oÃ¹ ce type de testing sera obligatoire: les mÃ©thodes pures. Ces mÃ©thodes n'ayant aucune dÃ©pendance ou variables partagÃ©es, elles n'ont donc aucun _side effect_. Le **black box testing** est donc une Ã©vidence mais cela rend aussi le test extrÃªmement robuste car rien ne vient impacter le rÃ©sultat du test.

Prenons par exemple une mÃ©thode `Sum` d'une classe `Calculator`. On est exactement sur le scÃ©nario mentionnÃ© plus haut:

```csharp title='tests/CalculatorTests.cs'
[TestClass]
public class CalculatorTests
{
	[TestMethod]
	public int Sum_Should_ReturnTheSumOfTheTwoNumbers()
	{
		Calculator calculator = new();

		int result = calculator.Sum(2,3);

		Assert.AreEqual(expected: 5, actual: result);
	}
}
```

On ne connaÃ®t pas l'implÃ©mentation de la mÃ©thode, mais on a Ã©crit un test. On lui donne des valeurs en entrÃ©e, et on vÃ©rifie la valeur de sortie.
Pour le reste des scÃ©narios, je trouve dommage de s'arrÃªter lÃ . C'est une prÃ©fÃ©rence personnelle, je trouve le **white box testing** plus pertinent en tant que _Mockist_.

De l'autre cÃ´tÃ©, on a donc ce **white box testing**. Ã€ premiÃ¨re vue, c'est la mÃªme chose: on donne un _input_ et on vÃ©rifie l'_output_. Mais on va aussi vÃ©rifier ce qu'il se passe Ã  l'intÃ©rieur du SUT.
On peut donc vÃ©rifier que le SUT a bien fait appel Ã  sa dÃ©pendance, que la valeur a bien Ã©tÃ© mise dans un cache, sauvegardÃ©e dans un repo, qu'un event a bien Ã©tÃ© Ã©mis, etc.
Cela nous permet de vÃ©rifier chaque _behavior_ avec ses _side effects_.

<AnchoredP id='how-to-write'>
	ğŸ”¸ La question que tous se posent... Comment Ã©crire de bons tests unitaires?
</AnchoredP>

ğŸ”¹ Je ne pense pas qu'il y ait de bons ou de mauvais tests unitaires... Evidemment que si!
Il faut rÃ©flÃ©chir avant sur ce que tu veux faire. Ã‡a peut paraÃ®tre bÃªte dit comme Ã§a mais _think before you do_. C'est que j'expliquais lorsque je parlais du fait que faire des tests te rend meilleur.
Si tu veux faire des tests efficaces, il faut rÃ©flÃ©chir sur la faÃ§on dont tes composants vont communiquer entre eux. En fait, tes tests seront efficaces Ã  partir du moment oÃ¹ ils seront faciles Ã  faire. Et si tu te rends compte qu'ils ne le sont pas, c'est qu'il y a un soucis dans ton code.

Exemple: j'ai un _service_ qui doit crÃ©er un utilisateur. **Avant d'Ã©crire mon test**, je dois me poser quelques questions: quelles sont les responsabilitÃ©s de mon service?
Est-il responsable d'envoyer une requÃªte HTTP Ã  un fournisseur externe pour rÃ©cupÃ©rer des informations? Est-il responsable de la persistence en base de donnÃ©es? Est-il responsable du _logging_?
_Divide &amp; Conquer_: une dÃ©pendance ici, une lÃ , et une autre lÃ ... Au final, que reste-t-il dans mon service? L'orchestration d'un processus dÃ©lÃ©guÃ© Ã  diffÃ©rentes dÃ©pendances (ex: client http, repository, logger, etc) et Ã©ventuellement une modification de l'Ã©tat d'une entitÃ©. C'est tout.

Au final, un "bon" test doit:

-   te protÃ©ger contre les rÃ©gressions ;
-   Ãªtre rÃ©sistant au refactoring ;
-   te donner un feedback rapide ;
-   Ãªtre maintenable.

<AnchoredP id='tips-to-start'>
	ğŸ”¸ Et, sinon... T'as des conseils pour se lancer dans le testing unitaire?
</AnchoredP>

ğŸ”¹ Je recommande aux personnes qui veulent dÃ©marrer le testing de commencer directement avec le _Test Driven Development_.
Si le test est Ã©crit aprÃ¨s l'implÃ©mentation, c'est pas vraiment objectif car tu connais dÃ©jÃ  l'implÃ©mentation donc ton test est fortement liÃ© Ã  ton implÃ©mentation. De plus, le code fonctionne dÃ©jÃ  donc le test sera perÃ§u comme une perte de temps. Mais surtout: on a bÃ©nÃ©ficiÃ© d'aucun avantage du testing lors de la phase d'implÃ©mentation.

Pour cela, vous n'Ãªtes pas seul. Il existe des tonnes de resources disponibles pour vous aider.
Voici plusieurs livres que j'aurais aimÃ© avoir lus au dÃ©but de ma carriÃ¨re:

-   "Test Driven Development - By Example" par Kent Beck.
-   "Unit Testing - Principles, Practices and Patterns" par Vladimir Khorikov.

Ã‰galement, voici un site rempli de conseils et astuces sur TDD avec un grand nombre de katas pour progresser: [TDD Buddy](http://www.tddbuddy.com/).

En parlant de katas, faites des katas. Faites pleins de katas et faites en Ã  plusieurs (_pair_ et/ou _mob programming_) si vous en avez la possibilitÃ©. C'est fun et c'est trÃ¨s formatteur, notamment sur le fait de dÃ©marrer avec des exercices simples et progressivement augmenter la difficultÃ© jusqu'Ã  se retrouver avec des situations similaires Ã  ce que l'on peut trouver dans des projets rÃ©els. En plus de [TDD Buddy](http://www.tddbuddy.com/), je pourrais recommander [Code Wars](https://www.codewars.com/) si vous Ãªtes en manque d'inspiration.
Sans forcÃ©ment faire de l'auto-promotion, vous pouvez aussi trouver quelques katas sur mon [GitHub](https://github.com/Tr00d/).

Un dernier conseil pour dÃ©marrer le testing, on peut se rÃ©fÃ©rer Ã  ce qu'on appelle le triple A (AAA), qui signifie _Arrange, Act, Assert_, pour rendre les tests plus clairs et organisÃ©s. Le but est de diviser son test unitaire en 3 parties distinctes:

1. _arrange_ : c'est le scÃ©nario, la partie oÃ¹ tu prÃ©pares les donnÃ©es _input_ de ta mÃ©thode ;
2. _act_ : c'est l'action, le fait de rÃ©aliser l'appel Ã  la mÃ©thode que tu vas tester ;
3. _assert_ : c'est la vÃ©rification du _behavior_, lÃ  partie oÃ¹ tu vÃ©rifies l'_output_ ou les _side effects_.

<AnchoredP id='bad-smells'>
	ğŸ”¸ Quels sont les "bad smells" dans l'unit testing?
</AnchoredP>

ğŸ”¹ J'en vois quelques-uns...

-   une partie _arrange_ qui fait 15 lignes... C'est trop compliquÃ©. On voit clairement que la mÃ©thode testÃ©e fait trop de choses car le scÃ©nario est trop compliquÃ© Ã  mettre en place!
-   On dit qu'**un test ne doit avoir qu'une et une seule raison d'Ã©chouer**. Un test ne devrait contenir qu'un seul _assert_.
-   Le fait que tu aies du mal Ã  Ã©crire des tests unitaires, non pas Ã  cause du fait que tu n'aies pas la connaissance nÃ©cessaire mais plutÃ´t en rapport au code Ã  tester... c'est qu'il y a un soucis au niveau de ton composant. Alors, prends du recul et penses aux responsabilitÃ©s.

<AnchoredH2 id='more-stuff'>Pour aller plus loin</AnchoredH2>

<AnchoredP id='libraries'>
	ğŸ”¸ Tu as des librairies intÃ©ressantes en tÃªte pour faciliter le travail?
</AnchoredP>

ğŸ”¹ Oui. Pour moi, on peut considÃ©rer trois groupes de librairies:

1. les librairies de testing qui permettent de gÃ©nÃ©rer des tests ;
2. les librairies de mocking qui permettent de surcharger le comportement de tes dÃ©pendances et de les monitorer ;
3. les librairies de gÃ©nÃ©ration de donnÃ©es.

Pour ma part:

|                     **Frameworks de test**                     |                **Librairies de mocking**                 |          **Librairies de gÃ©nÃ©ration de donnÃ©es**           |
| :------------------------------------------------------------: | :------------------------------------------------------: | :--------------------------------------------------------: |
| [MSTest](https://www.nuget.org/packages/MSTest.TestFramework/) |        [Moq](https://www.nuget.org/packages/Moq/)        | [AutoFixture](https://www.nuget.org/packages/AutoFixture/) |
|         [NUnit](https://www.nuget.org/packages/NUnit/)         |    [NInject](https://www.nuget.org/packages/Ninject/)    |
|         [XUnit](https://www.nuget.org/packages/xunit/)         | [WireMock](https://www.nuget.org/packages/WireMock.Net/) |

ğŸ”¸ Sur ce point-ci particuliÃ¨rement, j'aimerais mettre en avant le fait qu'il existe aussi des librairies de test pour le _front-end_. En fait, le testing unitaire n'est pas rÃ©servÃ© aux dÃ©veloppeurs
_back-end_. On citera notamment [Jest](https://www.npmjs.com/package/jest), [Mocha](https://www.npmjs.com/package/mocha), [Cypress](https://www.npmjs.com/package/cypress) et [Jasmine](https://www.npmjs.com/package/jasmine) comme librairies fortement liÃ©es au testing dans des applications JavaScript.

<AnchoredP id='what-is-tdd'>
	Du coup, tu n'arrÃªtes pas d'en parler. C'est quoi le{' '}
	<span style={{ fontStyle: 'italic' }}>Test Driven Development</span> (TDD)?
</AnchoredP>

ğŸ”¹ Je suis content que tu poses enfin la question! C'est pas comme si je t'avais tendu la perche plus d'une fois... C'est la joie, le bonheur, la rÃ©ponse ultime au sens de la vie, c'est tout Ã§a!
Non, je rigole. En fait, c'est une faÃ§on de mettre les tests au centre de ce que tu fais. On a parlÃ© de tous les points positifs de faire des tests unitaires et aussi du fait qu'on les perdait si on faisait les tests Ã  la fin sans forcÃ©ment aller dans le dÃ©tail.
En fait, la meilleure faÃ§on de bÃ©nÃ©ficier des avantages des tests, c'est de les faire en premier mais ce n'est pas que Ã§a. Ce n'est pas d'abord faire tous les tests puis ensuite faire l'implÃ©mentation.
Non, il y vraiment un aspect itÃ©ratif que l'on retrouve d'ailleurs dans l'AgilitÃ©. Tu y vas Ã©tape par Ã©tape (_baby steps_), tu ajoutes de nouveaux _behaviors_ en garantissant que ceux prÃ©cÃ©demment ajoutÃ©s fonctionnent toujours. Le filet de sÃ©curitÃ© s'agrandit petit Ã  petit naturellement.
On peut prÃ©senter cela diffÃ©remment: imaginons une Ã©chelle. Cela sera toujours plus facile de la monter marche par marche que de les monter trois par trois.

J'ajouterais que contrairement aux idÃ©es reÃ§ues, TDD ne rend pas la durÃ©e de dÃ©veloppement plus longue, bien au contraire. Par exemple, il n'est pas nÃ©cessaire d'exÃ©cuter la solution pour savoir que le code fonctionne car il a entiÃ¨rement Ã©tÃ© dÃ©veloppÃ© sur base de tests.

<Figure
	data={{
		src: '/img/test-driven-development.png',
		alt: 'Cycle du TDD',
		type: 'image',
		style: { border: '.5em solid black' },
	}}>
	Le cycle de dÃ©veloppement sous TDD
</Figure>

La premiÃ¨re Ã©tape, c'est l'Ã©criture d'**un** test unitaire. Normalement, ce test doit _obligatoirement_ Ã©chouer puisqu'aucune implÃ©mentation n'a Ã©tÃ© Ã©crite pour qu'il rÃ©ussise.
L'Ã©tape suivante, c'est donc d'Ã©crire le code qui permet de faire passer le test au vert. Et lÃ , c'est trÃ¨s important de savoir que ce passage de rouge vers le vert doit Ãªtre **le plus court possible**. C'est le moment oÃ¹ on Ã  le droit d'Ã©crire du code "moche", d'_hardcoder_ un rÃ©sultat, de dupliquer, de coller une rÃ©ponse de StackOverflow, etc. Cela peut paraÃ®tre bizarre au dÃ©but mais il y a un vrai intÃ©rÃªt: vÃ©rifier que l'ajout d'un nouveau _behavior_ est possible sans casser tout ce qui a Ã©tÃ© fait auparavant.
L'Ã©tape suivante, c'est le refactoring. On a fait un code horrible, il faut maintenant faire quelque chose de propre. J'ai parlÃ© plus tÃ´t de refactoring plus simple et sÃ©curisÃ©: on y est! On a notre _green light_ et le _behavior_ est garanti tant que cette _light_ reste _green_. On a notre _fast feedback loop_ Ã  portÃ©e de main (ou de clic, ou de raccourci) pour savoir si tout est ok. Tu me suis?
Ensuite, on atteint la fin du cycle. Cela veut dire une chose: on recommence.

ğŸ”¸ Je vais fournir un petit exemple pour que tout le monde se situe! Je vais faire Ã§a avec un calculateur de longueur de chaÃ®ne de caractÃ¨res tiens, c'est simple Ã  rÃ©aliser.
Donc, je commence par Ã©crire le test unitaire:

```csharp title='tests/StringCalculatorTests.cs'
[TestClass]
public class StringCalculatorTests
{
	[TestMethod]
	public int Length_ShouldReturn_CorrectLength()
	{
		StringCalculator calculator = new();

		int result = calculator.Length("string"); // "string" fait 6 caractÃ¨res de long, non?

		Assert.AreEqual(expected: 6, actual: result);
	}
}
```

Le test Ã©choue parce que je n'ai pas encore crÃ©Ã© la classe `StringCalculator`. Prochaine Ã©tape!

```csharp title='src/StringCalculator.cs'
public class StringCalculator
{
	public int Length (string str)
	{
		return 6;
	}
}
```

Ici, nous sommes donc Ã  l'Ã©tape verte. On doit donc passer Ã  l'Ã©tape bleue.

ğŸ”¹ J'ajouterais que ton code est super moche vu que tu as _hardcodÃ©_ la valeur. Mais c'est bien! C'est le but!

ğŸ”¸ La plus longue: rÃ©aliser un refactoring du code qui nous permet de rÃ©pondre au besoin demandÃ© (calculer la longueur d'une chaÃ®ne de caractÃ¨res) tout en ne cassant pas le test:

```csharp title='src/StringCalculator.cs'
public class StringCalculator
{
	public int Length (string str)
	{
		return str.Length; // la maniÃ¨re la plus propre de renvoyer la longueur d'une chaÃ®ne de caractÃ¨res en C#
	}
}
```

Et voilÃ ! Nous pouvons commencer l'Ã©criture d'un nouveau test unitaire.

ğŸ”¹ C'est un exemple assez simple mais tu y es. Il faut bien noter qu'il y a tout de mÃªme des rÃ¨gles Ã  respecter avec TDD mais je pourrais en parler pendant des heures alors on va s'arrÃªter ici!

<AnchoredP id='what-is-tcr'>
	ğŸ”¸ D'accord! D'ailleurs, j'ai ouÃ¯e dire que t'as rÃ©cemment appris le{' '}
	<span style={{ fontStyle: 'italic' }}>
		Test &amp;&amp; Commit || Revert
	</span>{' '}
	(TCR). Tu sais expliquer en quoi Ã§a consiste?
</AnchoredP>

ğŸ”¹ Exact, j'ai eu la chance de prendre connaissance de cette pratique via un _workshop_. Pour schÃ©matiser, disons que c'est une vision extrÃªme de TDD. Le meilleur moyen de l'utiliser est avec un script sÃ©parÃ©.
Ce script va analyser ta solution Ã  chaque sauvegarde et va ensuite exÃ©cuter tous tes tests. Si tous tes tests sont vert, il crÃ©e un commit qui reprÃ©sente un Ã©tat stable de ta branche (Test &amp;&amp; Commit).
Si tu as un seul test qui ne passe plus, il fait un rollback pour revenir Ã  l'Ã©tat du dernier commit (Revert), qui lui est stable.
Cela te force Ã  avancer en _baby steps_ et une chose est mise en Ã©vidence: c'est ton dernier changement qui a cassÃ© quelque chose.

Au dÃ©but, tu passes par une phase de frustration parce que tu peux perdre du code mais justement, cela t'incite Ã  avancer petit Ã  petit pour limiter tes pertes. Plus tes _steps_ sont petites, moins tu risques de perdre du code. C'est un super enseignement en complÃ©ment de TDD.
Losque tu deviens relativement Ã  l'aise avec tout Ã§a, tu remarques que tu avances de plus en plus vite et surtout, tu as toujours une branche qui fonctionne.

<AnchoredH2 id='conclusion'>Conclusion</AnchoredH2>

<AnchoredP>ğŸ”¸ Un dernier mot pour clÃ´turer cette interview?</AnchoredP>

ğŸ”¹ "Victoriae mundis et mundis lacrima", ca ne veut absolument rien dire mais je trouve que c'est assez dans le ton.
Plus sÃ©rieusement, Ã§a fait dÃ©jÃ  un moment qu'on discute mais on a seulement grattÃ© la surface. Il reste beaucoup de points Ã  aborder sur le testing. Je conseillerais donc vivement aux lecteurs d'Ãªtre curieux sur le sujet, de lire et surtout de pratiquer. N'hÃ©sitez pas Ã  demander de l'aide autour de vous.
Et sinon, le testing, Ã§a vous tente?

<Figure
	data={{
		src: '/img/developers-deliver-working-solutions.jpg',
		alt: 'Developers deliver working solutions, not testable code',
		type: 'image',
		style: { width: '50%', border: '.1em grey solid' },
	}}
/>

<Newsletter url={MAILCHIMP_URL} />

export const toc = [
	{ value: 'PrÃ©sentation', id: 'presentation', level: 2 },
	{ value: 'Le sujet', id: 'topic', level: 2 },
		{ value: 'PremiÃ¨re rencontre', id: 'first-encounter', level: 3 },
		{ value: "Qu'est-ce que c'est", id: 'what-is-it', level: 3 },
		{ value: 'OÃ¹ Ã§a se situe dans la "hiÃ©rarchie des tests"', id: 'hierarchy-position', level: 3 },
		{ value: 'But du testing unitaire', id: 'objective', level: 3 },
		{ value: 'Avantages et inconvÃ©nients', id: 'pros-and-cons', level: 3 },
		{ value: 'Test Coverage', id: 'test-coverage', level: 3 },
		{ value: 'Le coÃ»t', id: 'cost', level: 3 },
	{ value: 'Plus en dÃ©tails', id: 'details', level: 2 },
		{ value: 'Black box &amp; white box, kÃ©sako', id: 'black-and-white-boxes', level: 3 },
		{ value: 'Comment en Ã©crire efficacement', id: 'how-to-write', level: 3 },
		{ value: 'Tips pour se lancer', id: 'tips-to-start', level: 3 },
		{ value: 'Les "Bad Smells"', id: 'bad-smells', level: 3 },
	{ value: 'Pour aller plus loin', id: 'more-stuff', level: 2 },
		{ value: "Librairies facilitant l'implÃ©mentation", id: 'libraries', level: 3 },
		{ value: 'Le Test Driven Development', id: 'what-is-tdd', level: 3 },
		{ value: 'Le Test &amp;&amp; Commit || Revert ', id: 'what-is-tcr', level: 3 }
	{ value: 'Conclusion', id: 'conclusion', level: 2 }
];
