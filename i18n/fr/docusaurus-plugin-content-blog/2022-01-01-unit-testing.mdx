---
slug: unit-testing
title: Les tests unitaires
tags: [test, test unitaire, programmation]
description: L'article du jour est fait en effort conjoint avec mon ancien collÃ¨gue et mentor <a href="https://www.linkedin.com/in/guillaumefaas/" target="_blank" rel="noreferrer noopener nofollow">Guillaume Faas</a> sous la forme d'une conversation entre 2 dÃ©veloppeurs. Joins-toi Ã  moi pour le remercier pour son incroyable implication dans l'Ã©criture de cet article! Nous espÃ©rons tous les 2 que tu vas l'adorer, autant que nous avons adorer l'Ã©crire!
image: img/unit-testing.jpg
---

import Figure from '../../../src/components/figure';
import SEO from '../../../src/components/seo';
import Reminder from '../../../src/components/reminder';
import Newsletter from '../../../src/components/newsletter';
import { MAILCHIMP_URL } from '../../../website_config.json';
import { AnchoredH2, AnchoredP } from '../../../src/components/AnchoredHeading';
import randomChoose from '../../../src/utils/randomChoose';

<a href='/blog/unit-testing'>
	<Figure
		data={{
			src: '/img/unit-testing.jpg',
			alt: 'Tests unitaires',
			type: 'image',
		}}
	/>
</a>

L'article du jour est fait en effort conjoint avec mon ancien collÃ¨gue et mentor <a href="https://www.linkedin.com/in/guillaumefaas/" target="_blank" rel="noreferrer noopener nofollow">Guillaume Faas</a>
(ğŸ”¹) sous la forme d'une conversation entre 2 dÃ©veloppeurs.

Joins-toi Ã  moi pour le remercier pour son incroyable implication dans l'Ã©criture de cet article! Nous espÃ©rons tous les 2 que tu vas l'adorer, autant que nous avons adorer l'Ã©crire.

<!--truncate-->

<SEO uri='blog/unit-testing' image='img/unit-testing.jpg' type='article' />

---

<Reminder />

---

_tldr; fais des katas en appliquant le Test Driven Development!_

<AnchoredH2 id='presentation'>PrÃ©sentation</AnchoredH2>

<AnchoredP>ğŸ”¸ Salut Guillaume! Tu sais te prÃ©senter s'il te plaÃ®t?</AnchoredP>

ğŸ”¹ Salut TinaÃ«l! Merci de m'avoir invitÃ© Ã  parler sur ton site. Mon nom est Guillaume Faas et je suis un expert .NET / Software Craftsman, actuellement employÃ© chez [Squaremiled S.A.](https://squaremiled.com/). Je dÃ©veloppe des logiciels depuis presque 10 ans, en ayant Ã©voluÃ© dans des environnements et secteurs d'activitÃ©s variÃ©s.

<AnchoredH2 id='topic'>Le sujet!</AnchoredH2>

<AnchoredP>ğŸ”¸ De quoi va-t-on parler aujourd'hui?</AnchoredP>

ğŸ”¹ On va parler de **test unitaire**! Qui l'eÃ»t cru?!

<AnchoredP id='first-encounter'>
	ğŸ”¸ Quand est-ce que t'y as touchÃ© pour la premiÃ¨re fois?
</AnchoredP>

ğŸ”¹ C'Ã©tait il y a longtemps. J'avais Ã  peine quelques annÃ©es d'expÃ©rience Ã  l'Ã©poque. J'Ã©tais employÃ© par la mÃªme sociÃ©tÃ© pendant une majeure partie de ma carriÃ¨re et, par rapport Ã  mon day-to-day, je pensais que j'avais dÃ©jÃ  tout vu.
En rÃ¨gle gÃ©nÃ©rale, lorsqu'on commence Ã  travailler pour la premiÃ¨re fois, on s'attend Ã  ce que les entreprises rÃ©alisent des produits dans les rÃ¨gles de l'art juste parce qu'il s'agit du milieu professionnel. Donc, notre premier rÃ©flexe n'Ã©tait pas de regarder ailleurs pour dÃ©couvrir d'autres pratiques.
Enfin, c'Ã©tait mon cas.

Revenons en au sujet principal! Je commenÃ§ais Ã  regarder des guidelines, des best-practices, des _patterns_, etc. Je suis tombÃ© sur plein de sujets excitants et surtout nouveaux. C'Ã©tait comme si j'avais mis les pieds dans un nouveau monde qui n'avait rien Ã  voir avec la routine dans laquelle j'Ã©tais ancrÃ©. Le _testing_ Ã©tait Ã©videmment l'un de ces sujets.
Evidemment, cela n'aura pas Ã©tÃ© une adoption immÃ©diate de ma part! Bien que je comprenais pourquoi le testing Ã©tait important ainsi que tous les bÃ©nÃ©fices associÃ©s, je pensais que c'Ã©tait trop dur parce que je ne voyais pas comment introduire des tests dans le projet sur lequel j'Ã©tais assignÃ©. Pour Ãªtre tout Ã  fait honnÃªte: OUI, c'Ã©tait dur.
Mais pas parce que c'Ã©tait du _testing_: le produit sur lequel je travaillais Ã©tait en fait un monolithe avec Ã©normÃ©ment de couplage et le testing aurait intÃ©grÃ© un (trop) gros refactoring.

Je savais que je devais d'abord apprendre des principes et des _patterns_ (principalement sur les faÃ§ons de construire une application maintenable) avant d'Ãªtre capable d'introduire des tests. Ã‡a m'a pris du temps avant que je ne sois vraiment apte Ã  travailler avec une approche test-driven.

<AnchoredP id='what-is-it'>
	ğŸ”¸ Ok! Par contre, histoire de ne pas perdre les lecteurs... tu sais expliquer
	ce qu'est test unitaire s'il te plaÃ®t?
</AnchoredP>

ğŸ”¹ Oui, bien sÃ»r! Un test unitaire, c'est un test qui vÃ©rifie un _unit of code_. La notion de _unit of code_ varie en fonction des Ã©coles de testing.
L'Ã©cole London (ou Mockist) vont voir cela comme le plus petit _chunk_, typiquement une classe ou une mÃ©thode.
Par contre, l'Ã©cole Detroit (ou Classicist) vont voir cela comme un ensemble de classes ou de mÃ©thodes. La variation tient surtout de la taille de ton SUT (System Under Test) et de la relation entre les diffÃ©rents collaborateurs.

Mais Ã  la fin, un test unitaire est simplement **un morceau de code qui valide qu'un autre morceau de code a le rÃ©sultat et/ou side-effect attendu par rapport Ã  un scÃ©nario donnÃ©**.

<AnchoredP id='hierarchy-position'>
	ğŸ”¸ D'accord, mais du coup, Ã§a se situe oÃ¹ dans la "hiÃ©rachie des tests"? Ne me
	dis pas Â« tout Ã  gauche Â» sinon je vais Ãªtre fÃ¢chÃ©!
</AnchoredP>

ğŸ”¹ Je vois que tu es observateur. En effet, sur ce schÃ©ma, Ã§a se situe tout Ã  fait Ã  gauche <img style={{ display: "inline" }} src="https://www.pinclipart.com/picdir/big/524-5246191_troll-face-meme-png-troll-face-clipart.png" width="16" height="16" />
mais la rÃ©ponse que tu attends, j'imagine que c'est pourquoi. Je suppose qu'ils ont suivi l'ordre de la pyamide de testing mais de gauche Ã  droite au lieux de bas en haut. Plus tu seras situÃ© vers la gauche, plus tes tests seront nombreux et rapides. La logique inverse est appliquÃ©e lorsque tu vas dans l'autre sens.

Nous, on se situe sur la partie "unit" puisque techniquement, il n'y a pas plus petit qu'un _unit_. On va absolument pas tester ce qu'il y a autour. Le test unitaire doit Ãªtre exÃ©cutÃ© de faÃ§on _standalone_ et tu dois te trouver dans un environnement _sandbox_.
C'est-Ã -dire que ton test unitaire n'a aucun impact sur l'extÃ©rieur du test, et si tu en lances plusieurs en parallÃ¨le, ils ne doivent pas avoir de side-effects les uns les autres.

Cela signifie donc que dans un test unitaire: on ne contacte pas de DB, on Ã©vite de faire une requÃªte HTTP, d'accÃ©der Ã  un fichier du systÃ¨me, etc. De la mÃªme faÃ§on, on ne va pas contacter les autres dÃ©pendances de la solution.
On reste vraiment "interne" Ã  la fonction.

<Figure
	data={{
		src: '/img/software-testing-types.png',
		alt: 'Types de Software Testing',
		type: 'image',
	}}
/>

Si je regarde l'image et que je parle de chaque point de la partie _functional testing_:

- l'_unit testing_, c'est vÃ©rifier qu'un composant fonctionne bien ;
- l'_integration testing_, c'est vÃ©rifier que certains composants fonctionnent bien entre eux ;
- et Ã§a continue ainsi en augmentant la portÃ©e des tests jusqu'Ã  l'_user acceptance testing_ qui consiste Ã  vÃ©rifier l'entiÃ¨retÃ© de l'application tout en Ã©vitant de contacter les dÃ©pendances externes (ex: des requÃªtes vers des fournisseurs de donnÃ©es extÃ©rieurs Ã  ton application).
  Ce qui signifie que l'on est sur le scope global de l'application et donc que potentiellement, on va aller jusqu'Ã  tester la base de donnÃ©es.

<AnchoredP>
	ğŸ”¸ D'accord! Mais pourquoi le testing, c'est pas rÃ©alisÃ© dans le monde
	professionnel? Aussi bien les tests unitaires que les tests d'intÃ©gration...
</AnchoredP>

ğŸ”¹ En rÃ©alitÃ©, la majeure partie des dÃ©veloppeurs n'Ã©crivent pas ou peu de tests. De plus, les tests d'intÃ©grations sont moins rÃ©pandus que les tests unitaires car ils sont plus complexes Ã  Ã©crire. Au final, cette tÃ¢che est souvent vue comme une corvÃ©e ou alors une extra-step que l'on fera uniquement si on a le temps.
Il est important de sÃ©parer test unitaire et test d'intÃ©gration car ils n'ont pas la mÃªme portÃ©e ni la mÃªme utilitÃ©.
Comme on en parlait avant, un test unitaire est _rapide_, il s'agit de notre _feedback loop_ la plus rapide. On va donc les executer souvent et il nous permettrons de savoir si un composant a subi une rÃ©gression.
Par contre, un test d'intÃ©gration sera plus lent mais couvrira un scope plus large et plus reprÃ©sentatif d'un environnement rÃ©el. Il aura donc plus de _valeur_. 
 
A noter qu'il n'y a pas d'obligation d'implÃ©menter les deux, on pourrait trÃ¨s bien avoir une _test suite_ composÃ©e uniquement de tests d'une seule de ces categories. Mais il convient de garder Ã  l'esprit que notre _test suite_ ne sera pas des plus efficaces.

<Figure
	data={{
		src: randomChoose(
			'https://miro.medium.com/max/600/1*xHibbXdcePT0GtpeZRgxSA.gif',
			'https://media4.giphy.com/media/hqq505vU9iHCOGySD5/giphy.gif',
			'https://media1.giphy.com/media/VXmWbcDSj2yqnsXUrF/giphy.gif'
		),
		alt: 'GIF on integration testing',
		type: 'image',
	}}
/>

<AnchoredP id='objective'>
	ğŸ”¸ C'est quoi le but du testing unitaire et quand est-ce que Ã§a devrait Ãªtre
	appliquÃ©?
</AnchoredP>

ğŸ”¹ Le but est assez simple: c'est de montrer qu'une mÃ©thode fonctionne comme tu l'attends. C'est-Ã -dire que tu vas avoir un comportement attendu, par exemple ta mÃ©thode `getSomething` doit te retourner quelque chose. Tu vas donc tester diffÃ©rents scÃ©narios et vÃ©rifier qu'elle se comporte toujours de la bonne faÃ§on.

Pour ce qui est du "quand", et bien c'est simple: Ã§a doit Ãªtre appliquÃ© Ã  partir du moment oÃ¹ tu as de la logique quelque part.

<AnchoredP id='pros-and-cons'>
	ğŸ”¸ Bah du coup, quels en sont les avantages et inconvÃ©nients de la mise en
	place de tests unitaires?
</AnchoredP>

ğŸ”¹ Comme dit prÃ©cÃ©demment, tu Ã©cris du code qui teste du code. Vu comme cela, on dirait surtout une charge de travail supplÃ©mentaire sauf qu'il existe de rÃ©els intÃ©rÃªts derriÃ¨re.

1. Le test unitaire sert de **filet de sÃ©curitÃ© contre la rÃ©gression**.

Que l'on applique TDD ou non, l'Ã©tape du refactoring intervient systÃ©matiquement dans un projet. Le problÃ¨me Ã©tant qu'Ã  partir du moment oÃ¹ l'on modifie quelque chose, il y a un risque de _rÃ©gression_. On parle de _rÃ©gression_ lorsque quelque chose fonctionnait auparavant et ne fonctionne plus maintenant. 
C'est prÃ©cisement ici que le test intervient: il permet de garantir que tes composants fonctionnent toujours comme attendu. Si jamais quelque chose ne fonctionne plus suite Ã  un changement, la _test suite_ t'affichera les tests qui ont dÃ©tectÃ© un problÃ¨me avec un beau rond rouge. Et Ã§a, du point de vue d'un dÃ©veloppeur, c'est Ã©norme! Cela veut dire que tu es beaucoup plus serein et que tu passes bien moins de temps Ã  vÃ©rifier que tes changements n'ont pas eu d'impacts indÃ©sirables sur le reste du code. Par exemple, il devient inutile de de relancer la solution, de vÃ©rifier chaque page de ton site ou chaque bouton de ton application mobile.

2. Ã‰crire des tests, Ã§a amÃ©liore forcÃ©ment la **qualitÃ© du code** de ton application.

C'est liÃ© Ã  ce dont on vient d'aborder. Il est probable que les lecteurs aient dÃ©jÃ  rencontrÃ© une situation similaire: lorsque l'on parle de refactoring Ã  un Product Owner ou Product Manager, la premiÃ¨re crainte est toujours que quelque chose ne fonctionne plus.
Si tu es couvert par une _test suite_, tu n'as pas peur du _refactoring_. C'est mÃªme l'inverse, tu es encouragÃ© Ã  faire du refactoring rÃ©guliÃ¨rement tout en Ã©tant protÃ©gÃ©.

3. Une suite de tests devient ce qu'on appelle une **living documentation**.

    Lorsque l'on parle de documentation, on a tous Ã  l'esprit les commentaires ou XmlDocumentation. Le problÃ¨me est qu'ils ne sont jamais Ã  jour avec le reste du code. Le code Ã©volue, la documentation non. Par contre, ton test unitaire sera toujours up-to-date. Si ce n'est pas le cas, alors ta _test suite_ ne te donnera pas le feu vert pour aller plus loin.

    C'est d'autant plus intÃ©ressant dans le cadre d'une arrivÃ©e d'un nouveau dÃ©veloppeur sur le projet. PlutÃ´t que de lire tout le code d'une mÃ©thode pour savoir ce qu'elle fait, il lui suffit de regarder les diffÃ©rents tests de cette methode. Chaque comportement sera reprÃ©sentÃ© par un test avec un naming explicite sur le scÃ©nario et rÃ©sultat attendu. **Ã‡a facilite donc l'_onboarding_!**


4. Cela **rÃ©duit le temps de dÃ©tection des bugs**.

On a Ã©voquÃ© le terme _short feedback loop_ un peu plus tÃ´t dans la discussion. Les tests unitaires sont trÃ¨s rapides Ã  executer, ils nous donnent un feedback presque instantanÃ© sur la santÃ© de la solution. Cela veut dire que l'on doit les Ã©xecuter rÃ©guliÃ¨rement. Je schÃ©matise mais on a un bouton (ou un raccourci) qui nous donne un status Vert/Rouge en quelques secondes. Actionner ce bouton doit devenir quelque chose de systÃ©matique.
Cela a dÃ©jÃ  un intÃ©rÃªt pour nous en tant que dÃ©veloppeurs mais ce n'est pas tout. On en parlera un peu plus tard!

5. C'est pas rÃ©ellement un avantage direct, mais je pense qu'il est important de le mentionner: **faire du testing te rend meilleur**.

   Pour faire en sorte que tu puisses Ã©crire des tests apportant une rÃ©elle valeur, tu dois respecter certains principes. Tu dois toujours avoir une certaine couche d'abstraction pour _mocker_ tes dÃ©pendances, tu dois pouvoir les injecter, tu dois limiter les responsabilitÃ©s de tes composants, etc... en fait tu vas te forcer Ã  appliquer plusieurs principes rÃ©guliÃ¨rement (SOLID par exemple).
   Du coup, cela te force Ã  casser tes composants, Ã  les dÃ©coupler, Ã  penser Ã  leurs intercations et responsabilitÃ©s. Bref, Ã  rÃ©flÃ©chir et Ã  te poser beaucoup dde questions. Mine de rien, on parle de _code design_! Et donc, action-rÃ©action: tu deviens meilleur au fil du temps. Cela fait trÃ¨s _Happy End_ mais tu vois oÃ¹ je veux en venir.

ğŸ”¸ Et comme c'est peu mis en place dans les entreprises, c'est vu comme "nouveau" et Ã§a motive Ã  en apprendre plus!

ğŸ”¹ Je te rejoins sur l'aspect nouveautÃ© mais il reste surtout prÃ©sent au dÃ©but. Mais il y a une partie d'interprÃ©tation dans tout cela: certains (comme toi) le voient comme quelque chose d'intÃ©ressant, d'autres le voient comme une corvÃ©e ou une pression supplÃ©mentaire. Tu trouveras toujours des personnes rÃ©fractaires aux tests pour des raisons diverses et variÃ©es. Peut-Ãªtre qu'on aura l'occasion d'aborder les raisons qui sont gÃ©nÃ©ralement Ã©voquÃ©es. 

Pour ce qui est des inconvÃ©nients, je dirais que:

1. On l'a mentionnÃ©, il y a des prÃ©-requis: il faut des notions sur les principes de l'orientÃ© objet (et notamment l'abstraction), sur l'injection de dÃ©pendances, sur les principes [SOLID](https://www.digitalocean.com/community/conceptual_articles/s-o-l-i-d-the-first-five-principles-of-object-oriented-design), etc.
2. Le fait que l'on trouve peu de projets avec de rÃ©elles _test suites_ rend l'apprentissage moins accessible. Il en va de mÃªme pour trouver un coach passionnÃ© par ce sujet. 
3. Il y a une courbe d'apprentissage/de progression assez importante. Tout le monde passe par une phase de frustration au dÃ©but parce que l'on est pas Ã  l'aise et on a l'impression d'Ãªtre plus lent. Il faut rÃ©sister et persÃ©vÃ©rer car les tests nous feront en rÃ©alitÃ© aller plus vite. On en parlera avec l'approche TDD.
4. Cela demande de la prÃ©paration : il faut rÃ©flÃ©chir Ã  l'architecture du projet, aux relations entre les diffÃ©rents composants, etc... Vu comme cela, ce n'est pas vraiment un inconvÃ©nient. Mais on ne peut pas se lancer tÃªte baissÃ©e dans un dÃ©veloppement sans un minimum de rÃ©flexion.
5. Il y a un manque de comprÃ©hension du cÃ´tÃ© des autres Ã©quipes intervenant sur le dÃ©veloppement du produit, notamment non-IT. On retombe toujours sur des discussions sur le ROI ou l'impact sur la vÃ©locitÃ©. 

On entend souvent dire que "cela prend du temps et que cela sera planifiÃ© plus tard" ou que "les dÃ©veloppeurs n'ont pas le temps" mais ces arguments ne sont pas vraiment valables.
En effet, le premier indique clairement un manque de vision et de comprÃ©hension du testing. DÃ©jÃ  parce que "plus tard" n'arrive jamais. Mais surtout, faire les tests Ã  la fin du dÃ©veloppement n'a aucun sens. On perd tous les avantages qu'apportent le testing. Je l'ai dÃ©jÃ  dis mais on en parlera avec l'approche TDD.
Ensuite, le second indique un problÃ¨me d'organisation. Les tests devraient Ãªtre inclus dans les estimations et pas comme un travail supplÃ©mentaire Ã  rÃ©aliser.

<AnchoredP id='bugs-still-occur'>
	ğŸ”¸ Parfois, tu as quand mÃªme des problÃ¨mes qui surviennent dans des
	applications couvertes par des tests unitaires. Pourquoi?
</AnchoredP>

ğŸ”¹ Ã‰videmment, le risque zÃ©ro n'existe pas. On parle de _test efficiency_. Tu peux trÃ¨s bien avoir des scenarios non-couverts ou des _corner-case_ qui n'ont pas Ã©tÃ© pensÃ©s. 
Mais tout va bien, on ne perd pas le contrÃ´le pour autant. La solution est toute simple: crÃ©e un test qui couvre le scope de ton bug (et donc qui Ã©choue), corrige ton bug et vÃ©rifie que ton test passe. 
Au final, mÃªme si tu auras tout de mÃªme des bugs, penses surtout Ã  la quantitÃ© de bugs qui aura Ã©tÃ© filtrÃ©e et corrigÃ©e en amont d'un merge.

<AnchoredP id='test-coverage'>
	ğŸ”¸ Et le <span style={{ fontStyle: 'italic' }}>test coverage</span>, dans tout
	Ã§a?
</AnchoredP>

ğŸ”¹ Evidemment, tester c'est super mais il faut aussi faire un status sur l'Ã©tat de la _test suite_. C'est lÃ  qu'on arrive sur le _code coverage_. C'est une mÃ©trique informative sur la progression de couverture de tests de ton application.
J'insiste vraiment sur le cÃ´tÃ© informatir. Ce serait une erreur de mesurer la qualitÃ© de la suite de tests sur base de sa couverture. C'est une mÃ©trique de quantitÃ© et non de qualitÃ©. 
J'ai dÃ©jÃ  lu des articles sur des sociÃ©tÃ©s qui ont intÃ©grÃ© la valeur de _code coverage_ dans les objectifs des dÃ©veloppeurs et cela a incitÃ© les dÃ©veloppeurs Ã  utiliser de faux tests pour faire gonfler le coverage. 

Le seul moyen de vÃ©rifier la qualitÃ© d'une suite unitaire d'un projet, c'est de se poser quelques questions:

- Est-ce que le temps de dÃ©veloppement gÃ©nÃ©ral des fonctionnalitÃ©s diminue avec le temps?
- Est-ce que la quantitÃ© de bugs trouvÃ©s en production diminue avec le temps?
- Est-ce que tu arrives Ã  facilement accueillir une nouvelle ressource au sein de l'Ã©quipe de dÃ©veloppement?
- Est-ce que les dÃ©veloppeurs ont confiance en leur _test suite_? Est-ce qu'elle est reprÃ©sentative de l'Ã©tat de santÃ© de la solution? Est-ce qu'un rond vert garantit vraiment qu'un composant fonctionne?

Le soucis, c'est que c'est dur de faire une mÃ©trique sur tous ces points. Tu remarques d'ailleurs que les trois premiÃ¨res font rÃ©fÃ©rence au temps.

<AnchoredP id='cost'>
	ğŸ”¸ Bon sinon... question coÃ»t, qu'est-ce qu'il en est? Parce que finalement,
	Ã©crire un test unitaire, c'est tout de mÃªme Ã©crire du code. Ã‡a coÃ»te!
</AnchoredP>

ğŸ”¹ Je vois lÃ  oÃ¹ tu veux en venir. Non, cela ne coute pas plus sauf si tu factures au caractÃ¨re!
MÃªme si tu Ã©cris plus de code, tu es vraiment gagnant et pas que sur l'aspect temps. Je t'ai dis qu'on devait parler de TDD? Parce que cela te fait mÃªme gagner du temps Ã  court-terme. Bref.
DÃ©velopper une fonctionnalitÃ© peut te prendre un peu plus de temps en sachant que cela dÃ©pendra surtout de ton aisance avec l'Ã©criture de tests. D'un autre cÃ´tÃ©, cela va surtout te "sauver la vie" pas mal de fois parce que tu vas Ã©viter Ã©normement de bugs qui, en temps normal,
seraient arrivÃ©s bien plus tard dans ton _process_, lors des tests utilisateur sur un environnement de QA ou en production. 
Toi qui voulait parler d'argent, **plus un bug est dÃ©couvert tard, plus il coÃ»te cher**:

<Figure
	data={{
		src: 'https://assets.deepsource.io/995f56d/images/blog/cost-of-fixing-bugs/chart.jpg',
		alt: 'CoÃ»t de correction des bugs',
		type: 'image',
		url: 'https://deepsource.io/blog/exponential-cost-of-fixing-bugs/',
	}}
>
	Le coÃ»t de correction d'un bug sur base du moment oÃ¹ il a Ã©tÃ© dÃ©tectÃ©, sourcÃ©
	chez{' '}
	<a href='https://deepsource.io/blog/exponential-cost-of-fixing-bugs/'>
		DeepSource
	</a>
	!
</Figure>

Et c'est tout Ã  fait normal. 

On peut repaler de la _fast feedback loop_: si un bug est dÃ©couvert par un test unitaire, c'est en local sur ta machine, juste aprÃ¨s le changement (_rebuild_ + _rerun test suite_). Il est identifiÃ© rapidement et corrigÃ© rapidement.
A contrario, un bug qui passe en production... il est dÃ©couvert par un utilisateur qui remonte le problÃ¨me Ã  ta _product team_ qui elle doit ouvrir un ticket dans ton backlog. Ce ticket, il va Ãªtre prioritisÃ© par ton _Product Owner_ pour Ãªtre inclu dans la prochaine itÃ©ration puis il sera assignÃ© Ã  un dÃ©veloppeur. En admettant que ce ne soit pas toi, il y aura une phase d'investigation (reproduction du bug), une phase de correction de bug et aprÃ¨s
Ã§a doit repartir sur tous les environnements et Ãªtre validÃ© par des _Quality Assurance Users_.

J'ai volontairement pris un cas extrÃªme pour montrer le pire scÃ©nario envisageable mais c'est aussi la faÃ§on d'Ãªtre le plus explicite sur le problÃ¨me.
Ce qu'il est important de retenir, c'est qu'un test peut faire gagner beaucoup de temps Ã  beaucoup de personnes, aussi simple soit-il.

_ndlr: pour en savoir plus sur les raisons qui font qu'un logiciel a des bugs, n'hÃ©sitez pas Ã  consulter [cette page](https://www.softwaretestinghelp.com/why-does-software-have-bugs) et [d'autres sur le web](https://www.google.com/search?q=why+do+softwares+have+bugs)!_

<AnchoredH2 id='details'>En dÃ©tails</AnchoredH2>

<AnchoredP id='black-and-white-boxes'>
	ğŸ”¸ Ok! Et si on parlait maintenant de{' '}
	<span style={{ fontStyle: 'italic' }}>black box</span> et{' '}
	<span style={{ fontStyle: 'italic' }}>white box testing</span>?
</AnchoredP>

ğŸ”¹ C'est le moment pour moi de te montrer mes talents insoupÃ§onnÃ©s de dessinateur!

<Figure
	data={{
		src: '/img/black-white-box-testing.png',
		alt: 'Black and white box testing',
		type: 'image',
		style: { border: '.5em solid black' },
	}}
>
	Les diffÃ©rences entre _black & white box testing_
</Figure>

Le **black box testing**, c'est donner une information d'entrÃ©e au SUT et vÃ©rifier l'information de sortie. C'est aussi simple que Ã§a: on ne prend pas en compte ce qu'il se passe Ã  l'intÃ©rieur de la mÃ©thode.
C'est pas mal, c'est un dÃ©but, mais je trouve que c'est dommage de s'arrÃªter lÃ . C'est typiquement le genre de tests ajoutÃ©s en cours de route sur une application _legacy_ oÃ¹ c'est compliquÃ© de vÃ©rifier tout ce qu'il se passe parce qu'il y a dÃ©jÃ  beaucoup.

Prenons par exemple une mÃ©thode `Sum` d'une classe `Calculator`. Cette classe n'a pas de dÃ©pendance. Le test sur une mÃ©thode pure (sans dÃ©pendance ou qui n'accÃ¨de qu'Ã  des variables partagÃ©es) est obligatoirement un _black box test_:

```csharp title='tests/CalculatorTests.cs'
[TestClass]
public class CalculatorTests
{
	[TestMethod]
	public int Sum_Should_ReturnTheSumOfTheTwoNumbers()
	{
		Calculator calculator = new();

		int result = calculator.Sum(2,3);

		Assert.AreEqual(expected: 5, actual: result);
	}
}
```

On ne connaÃ®t pas l'implÃ©mentation de la mÃ©thode, mais on a Ã©crit un test. On lui donne des valeurs en entrÃ©e, et on vÃ©rifie la valeur de sortie.

De l'autre cÃ´tÃ©, on a le **white box testing**. C'est concrÃ¨tement la mÃªme chose: on donne un _input_ et on vÃ©rifie l'_output_ (c'est le but d'un test unitaire, finalement). Mais on va aussi vÃ©rifier ce qu'il se passe Ã  l'intÃ©rieur de l'_unit of code_.
Et donc potentiellement vÃ©rifier que ta mÃ©thode a bien fait appel Ã  sa dÃ©pendance, que la valeur a bien Ã©tÃ© mise dans un cache, sauvegardÃ©e dans un repo, qu'un event a bien Ã©tÃ© Ã©mis, etc. et lÃ , tout de suite, Ã§a donne plus de valeurs Ã  ton test.
Parce qu'on va dÃ©finir le _behavior_ de ton test de faÃ§on plus prÃ©cise, plus complÃ¨te, en vÃ©rifiant ce qu'il se passe Ã  l'intÃ©rieur.

<AnchoredP id='why-not-popular'>
	ğŸ”¸ Ah d'accord! Mais du coup, pourquoi est-ce que ce n'est pas plus adoptÃ© par
	les dÃ©veloppeurs?
</AnchoredP>

ğŸ”¹ C'est vraiment une interprÃ©tation personnelle parce que je ne dÃ©tiens pas la sainte vÃ©ritÃ©.
Je pense que dans notre cas, malgrÃ© le fait que l'on fasse du dÃ©veloppement de logiciels depuis plusieurs dÃ©cennies, on n'est pas encore sur un dÃ©veloppement logiciel "mature": si tu regardes en dÃ©tails, tu verras exactement les mÃªmes problÃ¨mes dans tous les projets sur lesquels on peut travailler.
Rajoute Ã  Ã§a le fait que le testing unitaire n'est pas forcÃ©ment (bien) enseignÃ© quand on est Ã  l'Ã©cole, et de ce fait pas appliquÃ© en entreprise.

Par consÃ©quent, tu n'as pas d'apprentissage continu sur le sujet, et donc tu tombes dans un cercle vicieux : personne n'en fait donc personne n'en fait.
Puis, combien de fois n'as-tu pas entendu "on fera les tests Ã  la fin" quand tu proposes d'en faire? Alors que faire Ã§a, c'est perdre pratiquement tous les avantages!

<AnchoredP>
	ğŸ”¸ Personnellement, j'ai eu la chance de faire mes Ã©tudes dans une institution
	qui tenait Ã  coeur d'enseigner en Ã©tant alignÃ©e avec le monde professionel
	mais aussi vis-Ã -vis des nouvelles technologies. Et pourtant, nous n'avons eu
	qu'une introduction aux tests unitaires. En tant qu'Ã©tudiant, Ã§a te tombe
	dessus et tu n'as pas forcÃ©ment le bagage nÃ©cessaire pour comprendre tout ce
	que l'on te demande. Pour ma part, Ã  l'Ã©poque, je n'avais absolument pas
	compris l'utilitÃ© du testing unitaire, et j'avais bÃ¢clÃ© la question Ã 
	l'examen!
</AnchoredP>

ğŸ”¹ La nivellation par le bas est perpÃ©tuelle. C'est d'autant plus embÃªtant pour les gens qui sont de bonne volontÃ© et qui veulent mettre des tests unitaires en place.
Dans l'industrie (sauf sur les projets qui sont chapeautÃ©s par des boÃ®tes qui ont plutÃ´t bonne conscience), tu vas Ãªtre fortement incitÃ© Ã  faire du _quick and dirty_.
Le problÃ¨me, c'est que tu es sur des solutions qui n'ont dÃ©jÃ  pas de tests unitaires. Comme je le disais avant, quand tu n'as pas de tests et que ton systÃ¨me grandit Ã  tous les niveaux:

- tes dÃ©veloppements te prennent beaucoup plus de temps ;
- t'as de plus en plus de bugs Ã  rÃ©gler ;
- comme Ã§a te gÃ©nÃ¨re plus de bugs, t'as plus de travail et donc t'as moins de temps pour Ã©crire des tests sur ta solution existante...

  ...en sachant qu'il y a une courbe de progression. Tu ne peux pas dire Ã  ton Ã©quipe du jour au lendemain : "allez hop, aujourd'hui tout le monde Ã©crit des tests unitaires" et t'as 100% de coverage. Ã‡a, Ã§a n'existe pas.

Tu es dÃ©jÃ  sur un flux tendu parce que tu n'as pas fait tes tests en amont, ce qui fait que tu te tapes toutes les consÃ©quences dans la figure.
Et donc, inciter une adoption aux tests unitaires et Ã  TDD devient d'autant plus compliquÃ© parce que les gens sont dÃ©jÃ  totalement noyÃ©s.

<AnchoredP id='how-to-write'>
	ğŸ”¸ La question que tous se posent... Comment Ã©crire de bons tests unitaires?
</AnchoredP>

ğŸ”¹ Il faut rÃ©flÃ©chir avant sur ce que tu veux faire. Ca peut paraÃ®tre bÃªte, mais _think before you do_. Quand j'expliquais que les tests unitaires te rendent meilleurs, c'est parce qu'ils te forcent Ã  rÃ©flÃ©chir sur les relations entre tes composants.
Si tu veux faire des tests unitaires efficaces, alors il faut rÃ©flÃ©chir sur comment tes composants vont communiquer entre eux. En fait, tes tests seront efficaces Ã  partir du moment oÃ¹ ils seront faciles Ã  faire. Et si tu te rends compte qu'ils ne le sont pas, c'est qu'il y a un soucis dans ton code.

Exemple: j'ai un _command handler_ qui doit me crÃ©er une utilisateur dans une base de donnÃ©es. **Avant d'Ã©crire mon test**, je dois rÃ©flÃ©chir: qu'est-ce que je veux que mon _handler_ fasse et ne fasse pas?
Est-ce que je veux que mon _handler_ envoie une requÃªte HTTP Ã  un fournisseur externe pour rÃ©cupÃ©rer des informations? Est-ce que je veux que Ã§a soit directement lui qui fasse la sauvegarde en DB? Est-ce que je veux que Ã§a soit lui qui s'occupe du logging dans un fichier? Peut-Ãªtre pas.
Une dÃ©pendance ici, lÃ , et lÃ ... Au final, qu'est-ce qu'il reste dans mon _command handler_ ? L'exÃ©cution des diffÃ©rentes dÃ©pendances, peut-Ãªtre une modification du statut de l'Ã©tat d'une entitÃ©, et voilÃ .

Mais finalement, un test unitaire efficace, c'est un test qui est fiable qui apporte de la valeur Ã  ta solution et qui te protÃ¨ge des effets de bord pour plus tard. C'est ainsi qu'on mesure l'efficacitÃ© de ta suite de tests.

<AnchoredH2 id='more-stuff'>Pour aller plus loin</AnchoredH2>

<AnchoredP id='libraries'>
	ğŸ”¸ Tu as des librairies intÃ©ressantes en tÃªte pour faciliter le travail?
</AnchoredP>

ğŸ”¹ Oui. Pour moi, il faut considÃ©rer deux groupes de librairies:

1. les librairies de testing, qui permettent de gÃ©nÃ©rer des tests unitaires. Mais je pense que ce sont vraiment des choix personnels.
2. les librairies de mocking, qui permettent de surcharger le comportement de tes dÃ©pendances et notamment de les monitorer. Mais c'est pareil, c'est trÃ¨s subjectif.

Pour ma part:

|                     **Frameworks de test**                     |                 **Librairies de mocking**                  |
| :------------------------------------------------------------: | :--------------------------------------------------------: |
| [MSTest](https://www.nuget.org/packages/MSTest.TestFramework/) |         [Moq](https://www.nuget.org/packages/Moq/)         |
|         [NUnit](https://www.nuget.org/packages/NUnit/)         |     [NInject](https://www.nuget.org/packages/Ninject/)     |
|         [XUnit](https://www.nuget.org/packages/xunit/)         | [AutoFixture](https://www.nuget.org/packages/AutoFixture/) |
|                                                                |  [WireMock](https://www.nuget.org/packages/WireMock.Net/)  |

ğŸ”¸ Sur ce point-ci particuliÃ¨rement, j'aimerais mettre en avant le fait qu'il existe aussi des librairies de test pour le _front-end_. En fait, le testing unitaire n'est pas rÃ©servÃ© aux dÃ©veloppeurs
_back-end_. On citera notamment [Jest](https://www.npmjs.com/package/jest), [Mocha](https://www.npmjs.com/package/mocha), [Cypress](https://www.npmjs.com/package/cypress) et [Jasmine](https://www.npmjs.com/package/jasmine) comme librairies fortement liÃ©es au testing dans des applications JavaScript.

<AnchoredP id='tips-to-start'>
	ğŸ”¸ T'as des conseils pour se lancer dans le testing unitaire?
</AnchoredP>

ğŸ”¹ Je recommande aux personnes qui veulent faire du testing unitaire de commencer avec TDD. Il n'y a pas meilleur pied Ã  l'Ã©trier parce que c'est vraiment lÃ  que tu vas mettre ton _behavior_ en avant.
Faire ton test aprÃ¨s l'implÃ©mentation, c'est pas objectif car tu connais dÃ©jÃ  l'implÃ©mentation donc ton test est fortement liÃ© Ã  ton implÃ©mentation. Ce qui n'est pas forcÃ©ment le cas avec TDD (que Ã§a soit du _black_ ou du _white box testing_), tu peux avoir une infinitÃ© de tests diffÃ©rents.

Un autre conseil, c'est de les faire. Vraiment. De faire l'effort de les commencer et de les terminer!
Et Ãªtre critique vis-Ã -vis de son code. Si c'est compliquÃ© de tester, ce n'est pas Ã  cause des tests, mais probablement Ã  cause de la maniÃ¨re dont ton projet est structurÃ©.

Et comme dernier conseil, je dirais: fais des katas. Fais plein de katas en TDD et fais-en Ã  plusieurs. C'est trÃ¨s formateur! Tu peux en trouver plein sur [Code Wars](https://www.codewars.com/) et [TDD Buddy](http://www.tddbuddy.com/).

Et concernant la maniÃ¨re dont on les Ã©crit, on peut se rÃ©fÃ©rer Ã  ce qu'on appelle le triple A (AAA), qui signifie _Arrange, Act, Assert_. En gros, c'est diviser son test unitaire en 3 parties distinces:

1. _arrange_ : la partie oÃ¹ tu prÃ©pares les donnÃ©es _input_ de ta mÃ©thode.
2. _act_ : le fait de rÃ©aliser l'appel Ã  la mÃ©thode que tu vas tester.
3. _assert_ : le moment de vÃ©ritÃ©, c'est-Ã -dire la partie oÃ¹ tu vas vÃ©rifier l'_output_ de ta mÃ©thode.

<AnchoredP id='what-is-tdd'>
	ğŸ”¸ Du coup, tu n'arrÃªtes pas d'en parler. C'est quoi le{' '}
	<span style={{ fontStyle: 'italic' }}>Test Driven Development</span> (TDD)?
</AnchoredP>

ğŸ”¹ C'est la vie, la joie, le bonheur, c'est tout Ã§a! Non, je rigole. En fait, c'est une faÃ§on de mettre les tests au centre de ce que tu fais. On a parlÃ© de tous les points positifs de faire des tests unitaires, et on a aussi parlÃ© du fait qu'on les perdait si on faisait les tests Ã  la fin.
En fait, la meilleure faÃ§on de bÃ©nÃ©ficier des avantages des tests, c'est de les faire au dÃ©but d'un projet. Ce n'est pas que Ã§a. Ce n'est pas d'abord faire tous les tests puis ensuite faire l'implÃ©mentation. Non, il y vraiment un cÃ´tÃ© incrÃ©mental. Tu y vas Ã©tape par Ã©tape en faisant en sorte qu'Ã  chaque fois que tu avances, tu utilises tous les tests que tu as fait avant comme filet de sÃ©curitÃ© qui s'agrandit petit Ã  petit.
C'est plus facile de monter une Ã©chelle oÃ¹ chaque marche fait 10cm que de monter une Ã©chelle oÃ¹ chaque marche fait 1m.

<Figure
	data={{
		src: '/img/test-driven-development.png',
		alt: 'Black and white box testing',
		type: 'image',
		style: { border: '.5em solid black' },
	}}
>
	Le cycle de dÃ©veloppement sous TDD
</Figure>

La premiÃ¨re Ã©tape, c'est d'Ã©crire **un** test unitaire. Normalement, ce test doit _obligatoirement_ Ã©chouÃ© d'emblÃ©e, puisqu'aucune autre ligne de code n'a Ã©tÃ© Ã©crite pour qu'il rÃ©ussise (deuxiÃ¨me Ã©tape).
L'Ã©tape suivante, c'est donc d'Ã©crire le code qui permet de faire passer le test au vert. Et lÃ , c'est trÃ¨s important de savoir que ce passage de rouge vers le vert doit Ãªtre **le plus court possible**. Il ne faut Ã©crire que le code qui fait passer le test au vert, ni plus ni moins.
L'Ã©tape suivante, c'est de modifier le code afin qu'il s'adapte au mieux aux _requirements_ du projet.

ğŸ”¸ Je vais fournir un petit exemple pour que tout le monde se situe! Je vais faire Ã§a avec un calculateur de longueur de chaÃ®ne de caractÃ¨res tiens, c'est simple Ã  rÃ©aliser.
Donc, on commence par Ã©crire le test unitaire:

```csharp title='tests/StringCalculatorTests.cs'
[TestClass]
public class StringCalculatorTests
{
	[TestMethod]
	public int Length_ShouldReturn_CorrectLength()
	{
		StringCalculator calculator = new();

		int result = calculator.Length("string")

		Assert.AreEqual(expected: 6, actual: result);
	}
}
```

Le test Ã©choue parce que nous n'avons pas encore crÃ©Ã© la classe `StringCalculator`. Prochaine Ã©tape!

```csharp title='src/StringCalculator.cs'
public class StringCalculator
{
	public int Length (string str)
	{
		return 6;
	}
}
```

Ici, nous sommes donc Ã  l'Ã©tape verte. On doit donc passer Ã  l'Ã©tape bleue. La plus longue: rÃ©aliser un refactoring du code qui nous permet de rÃ©pondre au besoin demandÃ© (calculer la longueur d'une chaÃ®ne de caractÃ¨res) tout en ne cassant pas le test:

```csharp title='src/StringCalculator.cs'
public class StringCalculator
{
	public int Length (string str)
	{
		return str.Length;
	}
}
```

Et voilÃ ! Nous pouvons commencer l'Ã©criture d'un nouveau test unitaire.

ğŸ”¹ C'est un exemple assez simple mais tu y es. Il faut bien noter qu'il y a des rÃ¨gles dans le TDD, mais on peut en parler pendant des heures alors on va s'arrÃªter ici!

<AnchoredP id='what-is-tcr'>
	ğŸ”¸ D'accord! D'ailleurs, j'ai ouÃ¯e dire que t'as rÃ©cemment appris le{' '}
	<span style={{ fontStyle: 'italic' }}>Test && Commit || Revert</span> (TCR).
	Tu sais expliquer en quoi Ã§a consiste?
</AnchoredP>

ğŸ”¹ Alors grosso modo, TCR, c'est une facon d'aller plus loin avec TDD. Le meilleur moyen d'utiliser Ã§a est avec un script sÃ©parÃ©.
Ce script va analyser ta solution Ã  chaque sauvegarde, et va exÃ©cuter tous tes tests. Si tous tes tests sont vert, il crÃ©e un commit qui represente un Ã©tat stable de ta branche (Test && Commit).
Si tu as un seul test qui foire, il fait un rollback pour revenir Ã  l'Ã©tat du dernier commit, stable du coup (Revert).
Ã‡a te force Ã  avancer en _baby steps_ et Ã§a part du principe que c'est ton dernier changement qui t'a fait foirer le truc.

Tu passes par une pÃ©riode de frustration parce que tu peux perdre du code mais justement, Ã§a t'incite Ã  avancer petit Ã  petit pour limiter tes pertes. C'est un super enseignement pour TDD.
Et quand tu es relativement Ã  l'aise avec tout Ã§a, Ã§a te fait aller plus vite car tu as toujours une branche qui fonctionne.

<AnchoredP id='bad-smells'>
	ğŸ”¸ Quels sont les "bad smells" dans l'unit testing?
</AnchoredP>

ğŸ”¹ Il y en a quelques-uns...

- Typiquement, le fait que la partie _arrange_ fasse 15 lignes... C'est trop compliquÃ©. On voit clairement que la mÃ©thode testÃ©e fait trop de choses!
- On dit qu'**un test ne doit avoir qu'une et une seule raison d'Ã©chouer**. Donc ton test ne doit contenir qu'un seul _assert_.
- Le fait que tu aies du mal Ã  Ã©crire des tests unitaires, non pas Ã  cause du fait que tu n'aies pas la connaissance nÃ©cessaire mais plutÃ´t en rapport au code Ã  tester... c'est qu'il y a un soucis au niveau de ton composant.
  Alors, repense Ã  ton architecture, repense Ã  tes liens.

<AnchoredH2 id='conclusion'>Conclusion</AnchoredH2>

<AnchoredP>ğŸ”¸ Un dernier mot pour clÃ´turer cette interview?</AnchoredP>

ğŸ”¹ J'ai une question Ã  poser aux lecteurs du coup... Vous allez en faire oui ou merde?

<Figure
	data={{
		src: '/img/developers-deliver-working-solutions.jpg',
		alt: 'Developers deliver working solutions, not testable code',
		type: 'image',
		style: { width: '50%', border: '.1em grey solid' },
	}}
/>

<Newsletter url={MAILCHIMP_URL} />

export const toc = [
	{
		value: 'PrÃ©sentation',
		id: 'presentation',
		children: [],
		level: 2,
	},
	{
		value: 'Le sujet',
		id: 'topic',
		children: [
			{
				value: 'PremiÃ¨re rencontre',
				id: 'first-encounter',
				children: [],
				level: 3,
			},
			{
				value: "Qu'est-ce que c'est",
				id: 'what-is-it',
				children: [],
				level: 3,
			},
			{
				value: 'OÃ¹ Ã§a se situe dans la "hiÃ©rarchie des tests"',
				id: 'hierarchy-position',
				children: [],
				level: 3,
			},
			{
				value: 'But du testing unitaire',
				id: 'objective',
				children: [],
				level: 3,
			},
			{
				value: 'Avantages et inconvÃ©nients',
				id: 'pros-and-cons',
				children: [],
				level: 3,
			},
			{
				value: 'Y toujours des bugs',
				id: 'bugs-still-occur',
				children: [],
				level: 3,
			},
			{
				value: 'Test Coverage',
				id: 'test-coverage',
				children: [],
				level: 3,
			},
			{
				value: 'Le coÃ»t',
				id: 'cost',
				children: [],
				level: 3,
			},
		],
		level: 2,
	},
	{
		value: 'Plus en dÃ©tails',
		id: 'details',
		children: [
			{
				value: 'Black box & white box, kÃ©sako',
				id: 'black-and-white-boxes',
				children: [],
				level: 3,
			},
			{
				value: 'ProblÃ¨me de popularitÃ©',
				id: 'why-not-popular',
				children: [],
				level: 3,
			},
			{
				value: 'Comment en Ã©crire efficacement',
				id: 'how-to-write',
				children: [],
				level: 3,
			},
		],
		level: 2,
	},
	{
		value: 'Pour aller plus loin',
		id: 'more-stuff',
		children: [
			{
				value: "Librairies facilitant l'implÃ©mentation",
				id: 'libraries',
				children: [],
				level: 3,
			},
			{
				value: 'Tips pour se lancer',
				id: 'tips-to-start',
				children: [],
				level: 3,
			},
			{
				value: 'Le Test Driven Development',
				id: 'what-is-tdd',
				children: [],
				level: 3,
			},
			{
				value: 'Le Test && Commit || Revert ',
				id: 'what-is-tcr',
				children: [],
				level: 3,
			},
			{
				value: 'Les "Bad Smells"',
				id: 'bad-smells',
				children: [],
				level: 3,
			},
		],
		level: 2,
	},
	{
		value: 'Conclusion',
		id: 'conclusion',
		children: [],
		level: 2,
	},
];
