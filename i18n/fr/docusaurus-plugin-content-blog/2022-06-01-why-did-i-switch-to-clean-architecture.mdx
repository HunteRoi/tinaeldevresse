---
slug: why-did-i-switch-to-clean-architecture
title: Quelle architecture j'utilise pour mes projets?
tags: [développement, structure, architecture]
description: J'ai décidé de parler du choix d'architecture que je prends quand je développe mes apps!
image: /img/why-did-i-switch-to-clean-architecture.png
---

import Figure from '../src/components/figure';
import SEO from '../src/components/seo';
import Reminder from '../src/components/reminder';
import Newsletter from '../src/components/newsletter';
import { MAILCHIMP_URL } from '../website_config.json';

<a href='/blog/why-did-i-switch-to-clean-architecture'>
    <Figure
        data={{
            src: '/img/why-i-love-clean-architecture.png',
            alt: 'Mon Amour pour la Clean Architecture',
            type: 'image'
        }}
    />
</a>

J'ai décidé de parler du choix d'architecture que je prends quand je développe mes apps!

<!--truncate-->

<SEO
    uri='blog/why-did-i-switch-to-clean-architecture'
    image='img/why-i-love-clean-architecture.png'
    type='article'
/>

---

<Reminder />

---

Il n'y a pas si longtemps, des collègues m'ont posé la question suivante:

> Comment est-ce que tu structures tes projets puisque lorsqu'ils évoluent, l'architecture "N-Tier" devient plus complexe et tend à créer des solutions en désordre.

Je n'ai pas toutes les réponses mais ce que j'ai répondu est que si ça touche à mes projets, je fais un simple choix:

-   Si je travaille sur une app CRUD basique, je choisis définitivement la 3-Tier architecture.
-   Mais si j'ai besoin de construire une application plus complexe qui nécessite une logique business importante et qui doit "crier son but", je choisis alors directement ce que Robert C. Martin a appelé [la Clean Architecture](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html) en 2012.
    Bien sûr, ma version ne suit pas strictement ce qu'Uncle Bob décrit dans son blog puisque je l'ai adapté à mes besoins mais parlons-en!

De nos jours cependant, j'ai plutôt tendance à faire pencher la balance en faveur du deuxième choix.
Mais **qu'est-ce que j'aime dans ce que m'apporte la Clean Architecture et non la N-Tier?**

## La N-Tier architecture

### Qu'est-ce que c'est?

Premièrement, ça serait une honte de vous parler de Clean Architecture et ne pas aborder l'enseignement que j'ai reçu à l'école : l'architecture n-tier.
Ce type d'archi est courament présenté et confondu avec l'une de ses versions spécifiques: l'architecture 3-tiers.

Cette archi met les données au centre. Elle est composée de 3 couches:

1. la couche Présentation, responsable de présenter l'information à l'extérieur ;
2. la couche Logique, responsable de la logique business qui doit être appliquée aux données ;
3. la couche Données, responsable de l'accès aux données (ORM, base de données, etc.).

<Figure
    data={{
        src: '/img/3-tier-architecture.jpg',
        alt: '3-tier schema',
        type: 'image'
    }}
/>

Bien sûr, le "n" signifie qu'il peut y avoir plus ou moins de couches. Les éléments décrits ci-dessus ne représente qu'un dénominateur commun.
Il existe des structures identiques comme l'archi 2-tiers, la Couche Unique, la 4-tiers, ...
Quand on développe un projet, on adapte l'architecture à ses besoins. Tu pourrais même sub-diviser les 3 couches ci-dessus en des sous-couches dépendamment de tes besoins.

### Avantages & Inconvénients

For the **avantages**, we can list the following:

-   more secure — The presentation layer (usually the UI or such) is not "directly" wired to the database. All connections to it are shielded by the logic layer.
-   easily maintainable — at the time of its "creation", this archi allowed the developers to maintain it much more easily than the previous architectures did.
-   easy to reuse — it is easier to reuse the logic of each layer.

For the **inconvénients**, let's have a quick look too:

-   increase in effort — implementing new features takes time as you have to go through all tiers.
    Changing a single thing in the database layer is reflected to the logic and presentation layers as they directly rely on it.
-   increase in complexity — when it grows, it becomes more difficult to keep it clean, understandable and predict the impact of a change.
-   harder to test — implementing tests is quite difficult as everything is highly coupled to the layer it points toward.

### Quand l'utiliser, selon moi?

In my humble opinion, using the n-tier architecture is a good start when you need to develop a prototype of an idea because you need to showcase something quickly.
This will unfortunately tend to make things less great for the future though.
You could also use this archi when you need to build an easy CRUD app.
Speaking of such, I decided to build a quick API to query one of my employers' database once using this structure.

## La Clean Architecture

### Qu'est-ce que c'est?

<Figure
    data={{
        src: '/img/clean-architecture.jpg',
        alt: 'Onion schema of CA',
        type: 'image'
    }}
/>

This architecture puts the Domain at the center, and in charge of everything. It also requires more intentional designs as you do not rely on your database directly.
Built with the [CQRS pattern](https://martinfowler.com/bliki/CQRS.html), I consider it the best way to write a software with maintainability and simplicity in mind.

Historical fact: the 3-Tiered architecture came in 1992 thanks to John J. Donovan and was followed by others afterwards:

-   Hexagonal Architecture / Ports & Adapters (2005, Alistair Cockburn),
-   Onion Architecture (2008, Jeffrey Palermo),
-   Clean Architecture (2012, Robert C. Martin).

### Avantages & Inconvénients

For the **avantages**, we can list the following:

-   less coupled code, better testability — as the code is less coupled due to using abstractions everywhere you can, you can easily mock dependencies and unit test your components.
    It also facilitates the development in each layer as they are not highly coupled together, allowing teams to work in parallel on each layer.
-   separation of concerns — the architecture kind of forces you to think about your use cases and dependencies.
    The UI also does not care about how your database looks, nor does it care about the packages you use to generate a PDF for example...
-   better features exposition
-   better application of SOLID principles
-   better evolutivity

For the **inconvénients**, we can list the following:

-   increase in time to build from scratch — you need to setup more things before starting to develop a valuable feature for the client.
-   increase in code — you need more files (classes and interfaces) than in an n-tier architecture.
-   possible loss of optimization — being closer to implementations might grant you better performances. You would lose this in profit of looser coupling which IMHO is a good trade-off.

### Quand l'utiliser, selon moi?

When you need to develop a complex software, that you want to test your features and want to deliver something valuable that will not increase the buglog once in production.
It can also be mixed with methodologies that make it a strong reliability like [DDD](https://en.wikipedia.org/wiki/Domain-driven_design) and [TDD](https://en.wikipedia.org/wiki/Test-driven_development).

## Du coup, pourquoi est-ce que je préfère cette dernière?

You might know now but I am tired of developing crappy things, I'm tired of working in a company where you get told to "develop fast and we will improve it later".
Later never comes.

I am so tired of such way of working that I fell in love with 3 things:

1. Clean Architecture, and
2. Test-Driven Development, and
3. [Software Craftsmanship](https://en.wikipedia.org/wiki/Software_craftsmanship).

I highly encourage you to learn more about these topics. They represent what I would love to call the best mindset for the next generation of developers.

## Conclusion

What finally makes the n-tier architecture obsolete is that it is actually _data-centric_ unlike the clean archi that is _centered around the logic_.
It took us time to understand that what gives value to our clients is not the data, but the business logic that allows to process that data!

I suggest that you check out these resources to have a more historical context, explanations and really accurate information on the topic:

-   The presentation of Guillherme Ferreira on [The Grand Unified Theory of Clean Architecture and Test Pyramid](https://youtu.be/fPSrA-YcHag?t=6724) at NDC Porto;
-   Mark Seemann's [article](https://blog.ploeh.dk/2013/12/03/layers-onions-ports-adapters-its-all-the-same/) on the topic of adapters;
-   [Sean G. Wright comment](https://dev.to/seangwright/comment/ccfb) on "Clean architecture - Your approach";
-   [Samuel Oloruntoba's explanations](https://www.digitalocean.com/community/conceptual_articles/s-o-l-i-d-the-first-five-principles-of-object-oriented-design) of the SOLID principles;
-   The meetup group of [Software Craftsmanship Luxembourg](https://www.meetup.com/fr-FR/software-craft-luxembourg/);
-   [Valentina Cupać's slides](https://www.jug.ch/events/slides/220201_Optivem_TDD_and_Clean_Architecture_Driven_by_Behaviour.pdf) about TDD and Clean Architecture driven by behaviour;
-   A blog post relating an [introduction to CA](https://medium.com/codex/introduction-to-clean-architecture-2437c6987ec)
-   If you want to see an example of this structure, don't hesitate to take a look at [Cloud Filesystem](https://github.com/hunteroi/cloud-filesystem), one of my open-sourced project!

And you, what architecture do you use for your projects?

<Newsletter url={MAILCHIMP_URL} />
